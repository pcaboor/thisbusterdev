"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_yacas_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/yacas.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/yacas.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yacas: function() { return /* binding */ yacas; }\n/* harmony export */ });\nfunction words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar bodiedOps = words(\"Assert BackQuote D Defun Deriv For ForEach FromFile \" +\n                      \"FromString Function Integrate InverseTaylor Limit \" +\n                      \"LocalSymbols Macro MacroRule MacroRulePattern \" +\n                      \"NIntegrate Rule RulePattern Subst TD TExplicitSum \" +\n                      \"TSum Taylor Taylor1 Taylor2 Taylor3 ToFile \" +\n                      \"ToStdout ToString TraceRule Until While\");\n\n// patterns\nvar pFloatForm  = \"(?:(?:\\\\.\\\\d+|\\\\d+\\\\.\\\\d*|\\\\d+)(?:[eE][+-]?\\\\d+)?)\";\nvar pIdentifier = \"(?:[a-zA-Z\\\\$'][a-zA-Z0-9\\\\$']*)\";\n\n// regular expressions\nvar reFloatForm    = new RegExp(pFloatForm);\nvar reIdentifier   = new RegExp(pIdentifier);\nvar rePattern      = new RegExp(pIdentifier + \"?_\" + pIdentifier);\nvar reFunctionLike = new RegExp(pIdentifier + \"\\\\s*\\\\(\");\n\nfunction tokenBase(stream, state) {\n  var ch;\n\n  // get next character\n  ch = stream.next();\n\n  // string\n  if (ch === '\"') {\n    state.tokenize = tokenString;\n    return state.tokenize(stream, state);\n  }\n\n  // comment\n  if (ch === '/') {\n    if (stream.eat('*')) {\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    }\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n\n  // go back one character\n  stream.backUp(1);\n\n  // update scope info\n  var m = stream.match(/^(\\w+)\\s*\\(/, false);\n  if (m !== null && bodiedOps.hasOwnProperty(m[1]))\n    state.scopes.push('bodied');\n\n  var scope = currentScope(state);\n\n  if (scope === 'bodied' && ch === '[')\n    state.scopes.pop();\n\n  if (ch === '[' || ch === '{' || ch === '(')\n    state.scopes.push(ch);\n\n  scope = currentScope(state);\n\n  if (scope === '[' && ch === ']' ||\n      scope === '{' && ch === '}' ||\n      scope === '(' && ch === ')')\n    state.scopes.pop();\n\n  if (ch === ';') {\n    while (scope === 'bodied') {\n      state.scopes.pop();\n      scope = currentScope(state);\n    }\n  }\n\n  // look for ordered rules\n  if (stream.match(/\\d+ *#/, true, false)) {\n    return 'qualifier';\n  }\n\n  // look for numbers\n  if (stream.match(reFloatForm, true, false)) {\n    return 'number';\n  }\n\n  // look for placeholders\n  if (stream.match(rePattern, true, false)) {\n    return 'variableName.special';\n  }\n\n  // match all braces separately\n  if (stream.match(/(?:\\[|\\]|{|}|\\(|\\))/, true, false)) {\n    return 'bracket';\n  }\n\n  // literals looking like function calls\n  if (stream.match(reFunctionLike, true, false)) {\n    stream.backUp(1);\n    return 'variableName.function';\n  }\n\n  // all other identifiers\n  if (stream.match(reIdentifier, true, false)) {\n    return 'variable';\n  }\n\n  // operators; note that operators like @@ or /; are matched separately for each symbol.\n  if (stream.match(/(?:\\\\|\\+|\\-|\\*|\\/|,|;|\\.|:|@|~|=|>|<|&|\\||_|`|'|\\^|\\?|!|%|#)/, true, false)) {\n    return 'operator';\n  }\n\n  // everything else is an error\n  return 'error';\n}\n\nfunction tokenString(stream, state) {\n  var next, end = false, escaped = false;\n  while ((next = stream.next()) != null) {\n    if (next === '\"' && !escaped) {\n      end = true;\n      break;\n    }\n    escaped = !escaped && next === '\\\\';\n  }\n  if (end && !escaped) {\n    state.tokenize = tokenBase;\n  }\n  return 'string';\n};\n\nfunction tokenComment(stream, state) {\n  var prev, next;\n  while((next = stream.next()) != null) {\n    if (prev === '*' && next === '/') {\n      state.tokenize = tokenBase;\n      break;\n    }\n    prev = next;\n  }\n  return 'comment';\n}\n\nfunction currentScope(state) {\n  var scope = null;\n  if (state.scopes.length > 0)\n    scope = state.scopes[state.scopes.length - 1];\n  return scope;\n}\n\nconst yacas = {\n  name: \"yacas\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scopes: []\n    };\n  },\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    return state.tokenize(stream, state);\n  },\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize !== tokenBase && state.tokenize !== null)\n      return null;\n\n    var delta = 0;\n    if (textAfter === ']' || textAfter === '];' ||\n        textAfter === '}' || textAfter === '};' ||\n        textAfter === ');')\n      delta = -1;\n\n    return (state.scopes.length + delta) * cx.unit;\n  },\n\n  languageData: {\n    electricInput: /[{}\\[\\]()\\;]/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS95YWNhcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQ0FBa0M7QUFDbEQseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5Qyx3QkFBd0Isc0JBQXNCO0FBQzlDLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3lhY2FzLmpzPzI5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGJvZGllZE9wcyA9IHdvcmRzKFwiQXNzZXJ0IEJhY2tRdW90ZSBEIERlZnVuIERlcml2IEZvciBGb3JFYWNoIEZyb21GaWxlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIkZyb21TdHJpbmcgRnVuY3Rpb24gSW50ZWdyYXRlIEludmVyc2VUYXlsb3IgTGltaXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiTG9jYWxTeW1ib2xzIE1hY3JvIE1hY3JvUnVsZSBNYWNyb1J1bGVQYXR0ZXJuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIk5JbnRlZ3JhdGUgUnVsZSBSdWxlUGF0dGVybiBTdWJzdCBURCBURXhwbGljaXRTdW0gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiVFN1bSBUYXlsb3IgVGF5bG9yMSBUYXlsb3IyIFRheWxvcjMgVG9GaWxlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIlRvU3Rkb3V0IFRvU3RyaW5nIFRyYWNlUnVsZSBVbnRpbCBXaGlsZVwiKTtcblxuLy8gcGF0dGVybnNcbnZhciBwRmxvYXRGb3JtICA9IFwiKD86KD86XFxcXC5cXFxcZCt8XFxcXGQrXFxcXC5cXFxcZCp8XFxcXGQrKSg/OltlRV1bKy1dP1xcXFxkKyk/KVwiO1xudmFyIHBJZGVudGlmaWVyID0gXCIoPzpbYS16QS1aXFxcXCQnXVthLXpBLVowLTlcXFxcJCddKilcIjtcblxuLy8gcmVndWxhciBleHByZXNzaW9uc1xudmFyIHJlRmxvYXRGb3JtICAgID0gbmV3IFJlZ0V4cChwRmxvYXRGb3JtKTtcbnZhciByZUlkZW50aWZpZXIgICA9IG5ldyBSZWdFeHAocElkZW50aWZpZXIpO1xudmFyIHJlUGF0dGVybiAgICAgID0gbmV3IFJlZ0V4cChwSWRlbnRpZmllciArIFwiP19cIiArIHBJZGVudGlmaWVyKTtcbnZhciByZUZ1bmN0aW9uTGlrZSA9IG5ldyBSZWdFeHAocElkZW50aWZpZXIgKyBcIlxcXFxzKlxcXFwoXCIpO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG5cbiAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAvLyBzdHJpbmdcbiAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZztcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBjb21tZW50XG4gIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoJyonKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdvIGJhY2sgb25lIGNoYXJhY3RlclxuICBzdHJlYW0uYmFja1VwKDEpO1xuXG4gIC8vIHVwZGF0ZSBzY29wZSBpbmZvXG4gIHZhciBtID0gc3RyZWFtLm1hdGNoKC9eKFxcdyspXFxzKlxcKC8sIGZhbHNlKTtcbiAgaWYgKG0gIT09IG51bGwgJiYgYm9kaWVkT3BzLmhhc093blByb3BlcnR5KG1bMV0pKVxuICAgIHN0YXRlLnNjb3Blcy5wdXNoKCdib2RpZWQnKTtcblxuICB2YXIgc2NvcGUgPSBjdXJyZW50U2NvcGUoc3RhdGUpO1xuXG4gIGlmIChzY29wZSA9PT0gJ2JvZGllZCcgJiYgY2ggPT09ICdbJylcbiAgICBzdGF0ZS5zY29wZXMucG9wKCk7XG5cbiAgaWYgKGNoID09PSAnWycgfHwgY2ggPT09ICd7JyB8fCBjaCA9PT0gJygnKVxuICAgIHN0YXRlLnNjb3Blcy5wdXNoKGNoKTtcblxuICBzY29wZSA9IGN1cnJlbnRTY29wZShzdGF0ZSk7XG5cbiAgaWYgKHNjb3BlID09PSAnWycgJiYgY2ggPT09ICddJyB8fFxuICAgICAgc2NvcGUgPT09ICd7JyAmJiBjaCA9PT0gJ30nIHx8XG4gICAgICBzY29wZSA9PT0gJygnICYmIGNoID09PSAnKScpXG4gICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuXG4gIGlmIChjaCA9PT0gJzsnKSB7XG4gICAgd2hpbGUgKHNjb3BlID09PSAnYm9kaWVkJykge1xuICAgICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuICAgICAgc2NvcGUgPSBjdXJyZW50U2NvcGUoc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGxvb2sgZm9yIG9yZGVyZWQgcnVsZXNcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXFxkKyAqIy8sIHRydWUsIGZhbHNlKSkge1xuICAgIHJldHVybiAncXVhbGlmaWVyJztcbiAgfVxuXG4gIC8vIGxvb2sgZm9yIG51bWJlcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChyZUZsb2F0Rm9ybSwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgLy8gbG9vayBmb3IgcGxhY2Vob2xkZXJzXG4gIGlmIChzdHJlYW0ubWF0Y2gocmVQYXR0ZXJuLCB0cnVlLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJ3ZhcmlhYmxlTmFtZS5zcGVjaWFsJztcbiAgfVxuXG4gIC8vIG1hdGNoIGFsbCBicmFjZXMgc2VwYXJhdGVseVxuICBpZiAoc3RyZWFtLm1hdGNoKC8oPzpcXFt8XFxdfHt8fXxcXCh8XFwpKS8sIHRydWUsIGZhbHNlKSkge1xuICAgIHJldHVybiAnYnJhY2tldCc7XG4gIH1cblxuICAvLyBsaXRlcmFscyBsb29raW5nIGxpa2UgZnVuY3Rpb24gY2FsbHNcbiAgaWYgKHN0cmVhbS5tYXRjaChyZUZ1bmN0aW9uTGlrZSwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICByZXR1cm4gJ3ZhcmlhYmxlTmFtZS5mdW5jdGlvbic7XG4gIH1cblxuICAvLyBhbGwgb3RoZXIgaWRlbnRpZmllcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChyZUlkZW50aWZpZXIsIHRydWUsIGZhbHNlKSkge1xuICAgIHJldHVybiAndmFyaWFibGUnO1xuICB9XG5cbiAgLy8gb3BlcmF0b3JzOyBub3RlIHRoYXQgb3BlcmF0b3JzIGxpa2UgQEAgb3IgLzsgYXJlIG1hdGNoZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBzeW1ib2wuXG4gIGlmIChzdHJlYW0ubWF0Y2goLyg/OlxcXFx8XFwrfFxcLXxcXCp8XFwvfCx8O3xcXC58OnxAfH58PXw+fDx8JnxcXHx8X3xgfCd8XFxefFxcP3whfCV8IykvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJ29wZXJhdG9yJztcbiAgfVxuXG4gIC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhbiBlcnJvclxuICByZXR1cm4gJ2Vycm9yJztcbn1cblxuZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmV4dCwgZW5kID0gZmFsc2UsIGVzY2FwZWQgPSBmYWxzZTtcbiAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChuZXh0ID09PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICBlbmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09PSAnXFxcXCc7XG4gIH1cbiAgaWYgKGVuZCAmJiAhZXNjYXBlZCkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICB9XG4gIHJldHVybiAnc3RyaW5nJztcbn07XG5cbmZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBwcmV2LCBuZXh0O1xuICB3aGlsZSgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAocHJldiA9PT0gJyonICYmIG5leHQgPT09ICcvJykge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldiA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuICdjb21tZW50Jztcbn1cblxuZnVuY3Rpb24gY3VycmVudFNjb3BlKHN0YXRlKSB7XG4gIHZhciBzY29wZSA9IG51bGw7XG4gIGlmIChzdGF0ZS5zY29wZXMubGVuZ3RoID4gMClcbiAgICBzY29wZSA9IHN0YXRlLnNjb3Blc1tzdGF0ZS5zY29wZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiBzY29wZTtcbn1cblxuZXhwb3J0IGNvbnN0IHlhY2FzID0ge1xuICBuYW1lOiBcInlhY2FzXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgc2NvcGVzOiBbXVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0sXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgICBpZiAoc3RhdGUudG9rZW5pemUgIT09IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGRlbHRhID0gMDtcbiAgICBpZiAodGV4dEFmdGVyID09PSAnXScgfHwgdGV4dEFmdGVyID09PSAnXTsnIHx8XG4gICAgICAgIHRleHRBZnRlciA9PT0gJ30nIHx8IHRleHRBZnRlciA9PT0gJ307JyB8fFxuICAgICAgICB0ZXh0QWZ0ZXIgPT09ICcpOycpXG4gICAgICBkZWx0YSA9IC0xO1xuXG4gICAgcmV0dXJuIChzdGF0ZS5zY29wZXMubGVuZ3RoICsgZGVsdGEpICogY3gudW5pdDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBlbGVjdHJpY0lucHV0OiAvW3t9XFxbXFxdKClcXDtdLyxcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIvL1wiLCBibG9jazoge29wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIn19XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/yacas.js\n"));

/***/ })

}]);