"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_scheme_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/scheme.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/scheme.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scheme: function() { return /* binding */ scheme; }\n/* harmony export */ });\nvar BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n    SYMBOL = \"symbol\", ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\nvar INDENT_WORD_SKIP = 2;\n\nfunction makeKeywords(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = makeKeywords(\"Î» case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\nvar indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\nfunction stateStack(indent, type, prev) { // represents a state stack object\n  this.indent = indent;\n  this.type = type;\n  this.prev = prev;\n}\n\nfunction pushStack(state, indent, type) {\n  state.indentStack = new stateStack(indent, type, state.indentStack);\n}\n\nfunction popStack(state) {\n  state.indentStack = state.indentStack.prev;\n}\n\nvar binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\nvar octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\nvar hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\nvar decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\nfunction isBinaryNumber (stream) {\n  return stream.match(binaryMatcher);\n}\n\nfunction isOctalNumber (stream) {\n  return stream.match(octalMatcher);\n}\n\nfunction isDecimalNumber (stream, backup) {\n  if (backup === true) {\n    stream.backUp(1);\n  }\n  return stream.match(decimalMatcher);\n}\n\nfunction isHexNumber (stream) {\n  return stream.match(hexMatcher);\n}\n\nfunction processEscapedSequence(stream, options) {\n  var next, escaped = false;\n  while ((next = stream.next()) != null) {\n    if (next == options.token && !escaped) {\n      options.state.mode = false;\n      break;\n    }\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\nconst scheme = {\n  name: \"scheme\",\n  startState: function () {\n    return {\n      indentStack: null,\n      indentation: 0,\n      mode: false,\n      sExprComment: false,\n      sExprQuote: false\n    };\n  },\n\n  token: function (stream, state) {\n    if (state.indentStack == null && stream.sol()) {\n      // update indentation, but only if indentStack is empty\n      state.indentation = stream.indentation();\n    }\n\n    // skip spaces\n    if (stream.eatSpace()) {\n      return null;\n    }\n    var returnType = null;\n\n    switch(state.mode){\n    case \"string\": // multi-line string parsing mode\n      processEscapedSequence(stream, {\n        token: \"\\\"\",\n        state: state\n      });\n      returnType = STRING; // continue on in scheme-string mode\n      break;\n    case \"symbol\": // escape symbol\n      processEscapedSequence(stream, {\n        token: \"|\",\n        state: state\n      });\n      returnType = SYMBOL; // continue on in scheme-symbol mode\n      break;\n    case \"comment\": // comment parsing mode\n      var next, maybeEnd = false;\n      while ((next = stream.next()) != null) {\n        if (next == \"#\" && maybeEnd) {\n\n          state.mode = false;\n          break;\n        }\n        maybeEnd = (next == \"|\");\n      }\n      returnType = COMMENT;\n      break;\n    case \"s-expr-comment\": // s-expr commenting mode\n      state.mode = false;\n      if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n        // actually start scheme s-expr commenting mode\n        state.sExprComment = 0;\n      }else{\n        // if not we just comment the entire of the next token\n        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n        returnType = COMMENT;\n        break;\n      }\n    default: // default parsing mode\n      var ch = stream.next();\n\n      if (ch == \"\\\"\") {\n        state.mode = \"string\";\n        returnType = STRING;\n\n      } else if (ch == \"'\") {\n        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n          if (typeof state.sExprQuote != \"number\") {\n            state.sExprQuote = 0;\n          } // else already in a quoted expression\n          returnType = ATOM;\n        } else {\n          stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n          returnType = ATOM;\n        }\n      } else if (ch == '|') {\n        state.mode = \"symbol\";\n        returnType = SYMBOL;\n      } else if (ch == '#') {\n        if (stream.eat(\"|\")) {                    // Multi-line comment\n          state.mode = \"comment\"; // toggle to comment mode\n          returnType = COMMENT;\n        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n          returnType = ATOM;\n        } else if (stream.eat(';')) {                // S-Expr comment\n          state.mode = \"s-expr-comment\";\n          returnType = COMMENT;\n        } else {\n          var numTest = null, hasExactness = false, hasRadix = true;\n          if (stream.eat(/[ei]/i)) {\n            hasExactness = true;\n          } else {\n            stream.backUp(1);       // must be radix specifier\n          }\n          if (stream.match(/^#b/i)) {\n            numTest = isBinaryNumber;\n          } else if (stream.match(/^#o/i)) {\n            numTest = isOctalNumber;\n          } else if (stream.match(/^#x/i)) {\n            numTest = isHexNumber;\n          } else if (stream.match(/^#d/i)) {\n            numTest = isDecimalNumber;\n          } else if (stream.match(/^[-+0-9.]/, false)) {\n            hasRadix = false;\n            numTest = isDecimalNumber;\n            // re-consume the initial # if all matches failed\n          } else if (!hasExactness) {\n            stream.eat('#');\n          }\n          if (numTest != null) {\n            if (hasRadix && !hasExactness) {\n              // consume optional exactness after radix\n              stream.match(/^#[ei]/i);\n            }\n            if (numTest(stream))\n              returnType = NUMBER;\n          }\n        }\n      } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n        returnType = NUMBER;\n      } else if (ch == \";\") { // comment\n        stream.skipToEnd(); // rest of the line is a comment\n        returnType = COMMENT;\n      } else if (ch == \"(\" || ch == \"[\") {\n        var keyWord = ''; var indentTemp = stream.column(), letter;\n        /**\n           Either\n           (indent-word ..\n           (non-indent-word ..\n           (;something else, bracket, etc.\n        */\n\n        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n          keyWord += letter;\n        }\n\n        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n          pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n        } else { // non-indent word\n          // we continue eating the spaces\n          stream.eatSpace();\n          if (stream.eol() || stream.peek() == \";\") {\n            // nothing significant after\n            // we restart indentation 1 space after\n            pushStack(state, indentTemp + 1, ch);\n          } else {\n            pushStack(state, indentTemp + stream.current().length, ch); // else we match\n          }\n        }\n        stream.backUp(stream.current().length - 1); // undo all the eating\n\n        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n        returnType = BRACKET;\n      } else if (ch == \")\" || ch == \"]\") {\n        returnType = BRACKET;\n        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n          popStack(state);\n\n          if(typeof state.sExprComment == \"number\"){\n            if(--state.sExprComment == 0){\n              returnType = COMMENT; // final closing bracket\n              state.sExprComment = false; // turn off s-expr commenting mode\n            }\n          }\n          if(typeof state.sExprQuote == \"number\"){\n            if(--state.sExprQuote == 0){\n              returnType = ATOM; // final closing bracket\n              state.sExprQuote = false; // turn off s-expr quote mode\n            }\n          }\n        }\n      } else {\n        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n          returnType = BUILTIN;\n        } else returnType = \"variable\";\n      }\n    }\n    return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n  },\n\n  indent: function (state) {\n    if (state.indentStack == null) return state.indentation;\n    return state.indentStack.indent;\n  },\n\n  languageData: {\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\n    commentTokens: {line: \";;\"}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zY2hlbWUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5TkFBeU47QUFDek4sb09BQW9PO0FBQ3BPLDBQQUEwUDtBQUMxUCx1aUJBQXVpQjs7QUFFdmlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0RBQWtEO0FBQ2xELGtDQUFrQztBQUNsQztBQUNBLFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0EsVUFBVSxzQkFBc0IscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFrRTtBQUMxRTtBQUNBLFFBQVEsaUJBQWlCLEtBQUs7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQSw4RUFBOEU7O0FBRTlFO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLHVCQUF1QixRQUFRO0FBQ25ELG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3NjaGVtZS5qcz81Y2Q2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBCVUlMVElOID0gXCJidWlsdGluXCIsIENPTU1FTlQgPSBcImNvbW1lbnRcIiwgU1RSSU5HID0gXCJzdHJpbmdcIixcbiAgICBTWU1CT0wgPSBcInN5bWJvbFwiLCBBVE9NID0gXCJhdG9tXCIsIE5VTUJFUiA9IFwibnVtYmVyXCIsIEJSQUNLRVQgPSBcImJyYWNrZXRcIjtcbnZhciBJTkRFTlRfV09SRF9TS0lQID0gMjtcblxuZnVuY3Rpb24gbWFrZUtleXdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBrZXl3b3JkcyA9IG1ha2VLZXl3b3JkcyhcIs67IGNhc2UtbGFtYmRhIGNhbGwvY2MgY2xhc3MgY29uZC1leHBhbmQgZGVmaW5lLWNsYXNzIGRlZmluZS12YWx1ZXMgZXhpdC1oYW5kbGVyIGZpZWxkIGltcG9ydCBpbmhlcml0IGluaXQtZmllbGQgaW50ZXJmYWNlIGxldCotdmFsdWVzIGxldC12YWx1ZXMgbGV0L2VjIG1peGluIG9wdC1sYW1iZGEgb3ZlcnJpZGUgcHJvdGVjdCBwcm92aWRlIHB1YmxpYyByZW5hbWUgcmVxdWlyZSByZXF1aXJlLWZvci1zeW50YXggc3ludGF4IHN5bnRheC1jYXNlIHN5bnRheC1lcnJvciB1bml0L3NpZyB1bmxlc3Mgd2hlbiB3aXRoLXN5bnRheCBhbmQgYmVnaW4gY2FsbC13aXRoLWN1cnJlbnQtY29udGludWF0aW9uIGNhbGwtd2l0aC1pbnB1dC1maWxlIGNhbGwtd2l0aC1vdXRwdXQtZmlsZSBjYXNlIGNvbmQgZGVmaW5lIGRlZmluZS1zeW50YXggZGVmaW5lLW1hY3JvIGRlZm1hY3JvIGRlbGF5IGRvIGR5bmFtaWMtd2luZCBlbHNlIGZvci1lYWNoIGlmIGxhbWJkYSBsZXQgbGV0KiBsZXQtc3ludGF4IGxldHJlYyBsZXRyZWMtc3ludGF4IG1hcCBvciBzeW50YXgtcnVsZXMgYWJzIGFjb3MgYW5nbGUgYXBwZW5kIGFwcGx5IGFzaW4gYXNzb2MgYXNzcSBhc3N2IGF0YW4gYm9vbGVhbj8gY2FhciBjYWRyIGNhbGwtd2l0aC1pbnB1dC1maWxlIGNhbGwtd2l0aC1vdXRwdXQtZmlsZSBjYWxsLXdpdGgtdmFsdWVzIGNhciBjZGRkYXIgY2RkZGRyIGNkciBjZWlsaW5nIGNoYXItPmludGVnZXIgY2hhci1hbHBoYWJldGljPyBjaGFyLWNpPD0/IGNoYXItY2k8PyBjaGFyLWNpPT8gY2hhci1jaT49PyBjaGFyLWNpPj8gY2hhci1kb3duY2FzZSBjaGFyLWxvd2VyLWNhc2U/IGNoYXItbnVtZXJpYz8gY2hhci1yZWFkeT8gY2hhci11cGNhc2UgY2hhci11cHBlci1jYXNlPyBjaGFyLXdoaXRlc3BhY2U/IGNoYXI8PT8gY2hhcjw/IGNoYXI9PyBjaGFyPj0/IGNoYXI+PyBjaGFyPyBjbG9zZS1pbnB1dC1wb3J0IGNsb3NlLW91dHB1dC1wb3J0IGNvbXBsZXg/IGNvbnMgY29zIGN1cnJlbnQtaW5wdXQtcG9ydCBjdXJyZW50LW91dHB1dC1wb3J0IGRlbm9taW5hdG9yIGRpc3BsYXkgZW9mLW9iamVjdD8gZXE/IGVxdWFsPyBlcXY/IGV2YWwgZXZlbj8gZXhhY3QtPmluZXhhY3QgZXhhY3Q/IGV4cCBleHB0ICNmIGZsb29yIGZvcmNlIGdjZCBpbWFnLXBhcnQgaW5leGFjdC0+ZXhhY3QgaW5leGFjdD8gaW5wdXQtcG9ydD8gaW50ZWdlci0+Y2hhciBpbnRlZ2VyPyBpbnRlcmFjdGlvbi1lbnZpcm9ubWVudCBsY20gbGVuZ3RoIGxpc3QgbGlzdC0+c3RyaW5nIGxpc3QtPnZlY3RvciBsaXN0LXJlZiBsaXN0LXRhaWwgbGlzdD8gbG9hZCBsb2cgbWFnbml0dWRlIG1ha2UtcG9sYXIgbWFrZS1yZWN0YW5ndWxhciBtYWtlLXN0cmluZyBtYWtlLXZlY3RvciBtYXggbWVtYmVyIG1lbXEgbWVtdiBtaW4gbW9kdWxvIG5lZ2F0aXZlPyBuZXdsaW5lIG5vdCBudWxsLWVudmlyb25tZW50IG51bGw/IG51bWJlci0+c3RyaW5nIG51bWJlcj8gbnVtZXJhdG9yIG9kZD8gb3Blbi1pbnB1dC1maWxlIG9wZW4tb3V0cHV0LWZpbGUgb3V0cHV0LXBvcnQ/IHBhaXI/IHBlZWstY2hhciBwb3J0PyBwb3NpdGl2ZT8gcHJvY2VkdXJlPyBxdWFzaXF1b3RlIHF1b3RlIHF1b3RpZW50IHJhdGlvbmFsPyByYXRpb25hbGl6ZSByZWFkIHJlYWQtY2hhciByZWFsLXBhcnQgcmVhbD8gcmVtYWluZGVyIHJldmVyc2Ugcm91bmQgc2NoZW1lLXJlcG9ydC1lbnZpcm9ubWVudCBzZXQhIHNldC1jYXIhIHNldC1jZHIhIHNpbiBzcXJ0IHN0cmluZyBzdHJpbmctPmxpc3Qgc3RyaW5nLT5udW1iZXIgc3RyaW5nLT5zeW1ib2wgc3RyaW5nLWFwcGVuZCBzdHJpbmctY2k8PT8gc3RyaW5nLWNpPD8gc3RyaW5nLWNpPT8gc3RyaW5nLWNpPj0/IHN0cmluZy1jaT4/IHN0cmluZy1jb3B5IHN0cmluZy1maWxsISBzdHJpbmctbGVuZ3RoIHN0cmluZy1yZWYgc3RyaW5nLXNldCEgc3RyaW5nPD0/IHN0cmluZzw/IHN0cmluZz0/IHN0cmluZz49PyBzdHJpbmc+PyBzdHJpbmc/IHN1YnN0cmluZyBzeW1ib2wtPnN0cmluZyBzeW1ib2w/ICN0IHRhbiB0cmFuc2NyaXB0LW9mZiB0cmFuc2NyaXB0LW9uIHRydW5jYXRlIHZhbHVlcyB2ZWN0b3IgdmVjdG9yLT5saXN0IHZlY3Rvci1maWxsISB2ZWN0b3ItbGVuZ3RoIHZlY3Rvci1yZWYgdmVjdG9yLXNldCEgd2l0aC1pbnB1dC1mcm9tLWZpbGUgd2l0aC1vdXRwdXQtdG8tZmlsZSB3cml0ZSB3cml0ZS1jaGFyIHplcm8/XCIpO1xudmFyIGluZGVudEtleXMgPSBtYWtlS2V5d29yZHMoXCJkZWZpbmUgbGV0IGxldHJlYyBsZXQqIGxhbWJkYSBkZWZpbmUtbWFjcm8gZGVmbWFjcm8gbGV0LXN5bnRheCBsZXRyZWMtc3ludGF4IGxldC12YWx1ZXMgbGV0Ki12YWx1ZXMgZGVmaW5lLXN5bnRheCBzeW50YXgtcnVsZXMgZGVmaW5lLXZhbHVlcyB3aGVuIHVubGVzc1wiKTtcblxuZnVuY3Rpb24gc3RhdGVTdGFjayhpbmRlbnQsIHR5cGUsIHByZXYpIHsgLy8gcmVwcmVzZW50cyBhIHN0YXRlIHN0YWNrIG9iamVjdFxuICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmV2ID0gcHJldjtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnQsIHR5cGUpIHtcbiAgc3RhdGUuaW5kZW50U3RhY2sgPSBuZXcgc3RhdGVTdGFjayhpbmRlbnQsIHR5cGUsIHN0YXRlLmluZGVudFN0YWNrKTtcbn1cblxuZnVuY3Rpb24gcG9wU3RhY2soc3RhdGUpIHtcbiAgc3RhdGUuaW5kZW50U3RhY2sgPSBzdGF0ZS5pbmRlbnRTdGFjay5wcmV2O1xufVxuXG52YXIgYmluYXJ5TWF0Y2hlciA9IG5ldyBSZWdFeHAoL14oPzpbLStdaXxbLStdWzAxXSsjKig/OlxcL1swMV0rIyopP2l8Wy0rXT9bMDFdKyMqKD86XFwvWzAxXSsjKik/QFstK10/WzAxXSsjKig/OlxcL1swMV0rIyopP3xbLStdP1swMV0rIyooPzpcXC9bMDFdKyMqKT9bLStdKD86WzAxXSsjKig/OlxcL1swMV0rIyopPyk/aXxbLStdP1swMV0rIyooPzpcXC9bMDFdKyMqKT8pKD89WygpXFxzO1wiXXwkKS9pKTtcbnZhciBvY3RhbE1hdGNoZXIgPSBuZXcgUmVnRXhwKC9eKD86Wy0rXWl8Wy0rXVswLTddKyMqKD86XFwvWzAtN10rIyopP2l8Wy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT9AWy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT98Wy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT9bLStdKD86WzAtN10rIyooPzpcXC9bMC03XSsjKik/KT9pfFstK10/WzAtN10rIyooPzpcXC9bMC03XSsjKik/KSg/PVsoKVxccztcIl18JCkvaSk7XG52YXIgaGV4TWF0Y2hlciA9IG5ldyBSZWdFeHAoL14oPzpbLStdaXxbLStdW1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/aXxbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP0BbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP3xbLStdP1tcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP1stK10oPzpbXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT8pP2l8Wy0rXT9bXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT8pKD89WygpXFxzO1wiXXwkKS9pKTtcbnZhciBkZWNpbWFsTWF0Y2hlciA9IG5ldyBSZWdFeHAoL14oPzpbLStdaXxbLStdKD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopaXxbLStdPyg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKUBbLStdPyg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKXxbLStdPyg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKVstK10oPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKik/aXwoPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKikpKD89WygpXFxzO1wiXXwkKS9pKTtcblxuZnVuY3Rpb24gaXNCaW5hcnlOdW1iZXIgKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLm1hdGNoKGJpbmFyeU1hdGNoZXIpO1xufVxuXG5mdW5jdGlvbiBpc09jdGFsTnVtYmVyIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5tYXRjaChvY3RhbE1hdGNoZXIpO1xufVxuXG5mdW5jdGlvbiBpc0RlY2ltYWxOdW1iZXIgKHN0cmVhbSwgYmFja3VwKSB7XG4gIGlmIChiYWNrdXAgPT09IHRydWUpIHtcbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICB9XG4gIHJldHVybiBzdHJlYW0ubWF0Y2goZGVjaW1hbE1hdGNoZXIpO1xufVxuXG5mdW5jdGlvbiBpc0hleE51bWJlciAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0ubWF0Y2goaGV4TWF0Y2hlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFc2NhcGVkU2VxdWVuY2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBuZXh0LCBlc2NhcGVkID0gZmFsc2U7XG4gIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmV4dCA9PSBvcHRpb25zLnRva2VuICYmICFlc2NhcGVkKSB7XG4gICAgICBvcHRpb25zLnN0YXRlLm1vZGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2NoZW1lID0ge1xuICBuYW1lOiBcInNjaGVtZVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGVudFN0YWNrOiBudWxsLFxuICAgICAgaW5kZW50YXRpb246IDAsXG4gICAgICBtb2RlOiBmYWxzZSxcbiAgICAgIHNFeHByQ29tbWVudDogZmFsc2UsXG4gICAgICBzRXhwclF1b3RlOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmluZGVudFN0YWNrID09IG51bGwgJiYgc3RyZWFtLnNvbCgpKSB7XG4gICAgICAvLyB1cGRhdGUgaW5kZW50YXRpb24sIGJ1dCBvbmx5IGlmIGluZGVudFN0YWNrIGlzIGVtcHR5XG4gICAgICBzdGF0ZS5pbmRlbnRhdGlvbiA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIHNraXAgc3BhY2VzXG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJldHVyblR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoKHN0YXRlLm1vZGUpe1xuICAgIGNhc2UgXCJzdHJpbmdcIjogLy8gbXVsdGktbGluZSBzdHJpbmcgcGFyc2luZyBtb2RlXG4gICAgICBwcm9jZXNzRXNjYXBlZFNlcXVlbmNlKHN0cmVhbSwge1xuICAgICAgICB0b2tlbjogXCJcXFwiXCIsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm5UeXBlID0gU1RSSU5HOyAvLyBjb250aW51ZSBvbiBpbiBzY2hlbWUtc3RyaW5nIG1vZGVcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzeW1ib2xcIjogLy8gZXNjYXBlIHN5bWJvbFxuICAgICAgcHJvY2Vzc0VzY2FwZWRTZXF1ZW5jZShzdHJlYW0sIHtcbiAgICAgICAgdG9rZW46IFwifFwiLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuVHlwZSA9IFNZTUJPTDsgLy8gY29udGludWUgb24gaW4gc2NoZW1lLXN5bWJvbCBtb2RlXG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29tbWVudFwiOiAvLyBjb21tZW50IHBhcnNpbmcgbW9kZVxuICAgICAgdmFyIG5leHQsIG1heWJlRW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IFwiI1wiICYmIG1heWJlRW5kKSB7XG5cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVFbmQgPSAobmV4dCA9PSBcInxcIik7XG4gICAgICB9XG4gICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzLWV4cHItY29tbWVudFwiOiAvLyBzLWV4cHIgY29tbWVudGluZyBtb2RlXG4gICAgICBzdGF0ZS5tb2RlID0gZmFsc2U7XG4gICAgICBpZihzdHJlYW0ucGVlaygpID09IFwiKFwiIHx8IHN0cmVhbS5wZWVrKCkgPT0gXCJbXCIpe1xuICAgICAgICAvLyBhY3R1YWxseSBzdGFydCBzY2hlbWUgcy1leHByIGNvbW1lbnRpbmcgbW9kZVxuICAgICAgICBzdGF0ZS5zRXhwckNvbW1lbnQgPSAwO1xuICAgICAgfWVsc2V7XG4gICAgICAgIC8vIGlmIG5vdCB3ZSBqdXN0IGNvbW1lbnQgdGhlIGVudGlyZSBvZiB0aGUgbmV4dCB0b2tlblxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxzXFwoXFwpXFxbXFxdXS8pOyAvLyBlYXQgc3ltYm9sIGF0b21cbiAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IC8vIGRlZmF1bHQgcGFyc2luZyBtb2RlXG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgICBpZiAoY2ggPT0gXCJcXFwiXCIpIHtcbiAgICAgICAgc3RhdGUubW9kZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHJldHVyblR5cGUgPSBTVFJJTkc7XG5cbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCInXCIpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIoXCIgfHwgc3RyZWFtLnBlZWsoKSA9PSBcIltcIil7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHN0YXRlLnNFeHByUXVvdGUgPSAwO1xuICAgICAgICAgIH0gLy8gZWxzZSBhbHJlYWR5IGluIGEgcXVvdGVkIGV4cHJlc3Npb25cbiAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXFwtISQlJiorXFwuXFwvOjw9Pj9AXFxefl0vKTtcbiAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PSAnfCcpIHtcbiAgICAgICAgc3RhdGUubW9kZSA9IFwic3ltYm9sXCI7XG4gICAgICAgIHJldHVyblR5cGUgPSBTWU1CT0w7XG4gICAgICB9IGVsc2UgaWYgKGNoID09ICcjJykge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcInxcIikpIHsgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpLWxpbmUgY29tbWVudFxuICAgICAgICAgIHN0YXRlLm1vZGUgPSBcImNvbW1lbnRcIjsgLy8gdG9nZ2xlIHRvIGNvbW1lbnQgbW9kZVxuICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoL1t0Zl0vaSkpIHsgICAgICAgICAgICAvLyAjdC8jZiAoYXRvbSlcbiAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCc7JykpIHsgICAgICAgICAgICAgICAgLy8gUy1FeHByIGNvbW1lbnRcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gXCJzLWV4cHItY29tbWVudFwiO1xuICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBudW1UZXN0ID0gbnVsbCwgaGFzRXhhY3RuZXNzID0gZmFsc2UsIGhhc1JhZGl4ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdCgvW2VpXS9pKSkge1xuICAgICAgICAgICAgaGFzRXhhY3RuZXNzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgLy8gbXVzdCBiZSByYWRpeCBzcGVjaWZpZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXiNiL2kpKSB7XG4gICAgICAgICAgICBudW1UZXN0ID0gaXNCaW5hcnlOdW1iZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14jby9pKSkge1xuICAgICAgICAgICAgbnVtVGVzdCA9IGlzT2N0YWxOdW1iZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14jeC9pKSkge1xuICAgICAgICAgICAgbnVtVGVzdCA9IGlzSGV4TnVtYmVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eI2QvaSkpIHtcbiAgICAgICAgICAgIG51bVRlc3QgPSBpc0RlY2ltYWxOdW1iZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bLSswLTkuXS8sIGZhbHNlKSkge1xuICAgICAgICAgICAgaGFzUmFkaXggPSBmYWxzZTtcbiAgICAgICAgICAgIG51bVRlc3QgPSBpc0RlY2ltYWxOdW1iZXI7XG4gICAgICAgICAgICAvLyByZS1jb25zdW1lIHRoZSBpbml0aWFsICMgaWYgYWxsIG1hdGNoZXMgZmFpbGVkXG4gICAgICAgICAgfSBlbHNlIGlmICghaGFzRXhhY3RuZXNzKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCcjJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudW1UZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChoYXNSYWRpeCAmJiAhaGFzRXhhY3RuZXNzKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnN1bWUgb3B0aW9uYWwgZXhhY3RuZXNzIGFmdGVyIHJhZGl4XG4gICAgICAgICAgICAgIHN0cmVhbS5tYXRjaCgvXiNbZWldL2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVRlc3Qoc3RyZWFtKSlcbiAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IE5VTUJFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoL15bLSswLTkuXS8udGVzdChjaCkgJiYgaXNEZWNpbWFsTnVtYmVyKHN0cmVhbSwgdHJ1ZSkpIHsgLy8gbWF0Y2ggbm9uLXByZWZpeGVkIG51bWJlciwgbXVzdCBiZSBkZWNpbWFsXG4gICAgICAgIHJldHVyblR5cGUgPSBOVU1CRVI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiO1wiKSB7IC8vIGNvbW1lbnRcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpOyAvLyByZXN0IG9mIHRoZSBsaW5lIGlzIGEgY29tbWVudFxuICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIoXCIgfHwgY2ggPT0gXCJbXCIpIHtcbiAgICAgICAgdmFyIGtleVdvcmQgPSAnJzsgdmFyIGluZGVudFRlbXAgPSBzdHJlYW0uY29sdW1uKCksIGxldHRlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAgIEVpdGhlclxuICAgICAgICAgICAoaW5kZW50LXdvcmQgLi5cbiAgICAgICAgICAgKG5vbi1pbmRlbnQtd29yZCAuLlxuICAgICAgICAgICAoO3NvbWV0aGluZyBlbHNlLCBicmFja2V0LCBldGMuXG4gICAgICAgICovXG5cbiAgICAgICAgd2hpbGUgKChsZXR0ZXIgPSBzdHJlYW0uZWF0KC9bXlxcc1xcKFxcW1xcO1xcKVxcXV0vKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGtleVdvcmQgKz0gbGV0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleVdvcmQubGVuZ3RoID4gMCAmJiBpbmRlbnRLZXlzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGtleVdvcmQpKSB7IC8vIGluZGVudC13b3JkXG5cbiAgICAgICAgICBwdXNoU3RhY2soc3RhdGUsIGluZGVudFRlbXAgKyBJTkRFTlRfV09SRF9TS0lQLCBjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIG5vbi1pbmRlbnQgd29yZFxuICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGVhdGluZyB0aGUgc3BhY2VzXG4gICAgICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lb2woKSB8fCBzdHJlYW0ucGVlaygpID09IFwiO1wiKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHNpZ25pZmljYW50IGFmdGVyXG4gICAgICAgICAgICAvLyB3ZSByZXN0YXJ0IGluZGVudGF0aW9uIDEgc3BhY2UgYWZ0ZXJcbiAgICAgICAgICAgIHB1c2hTdGFjayhzdGF0ZSwgaW5kZW50VGVtcCArIDEsIGNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnRUZW1wICsgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGgsIGNoKTsgLy8gZWxzZSB3ZSBtYXRjaFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uYmFja1VwKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoIC0gMSk7IC8vIHVuZG8gYWxsIHRoZSBlYXRpbmdcblxuICAgICAgICBpZih0eXBlb2Ygc3RhdGUuc0V4cHJDb21tZW50ID09IFwibnVtYmVyXCIpIHN0YXRlLnNFeHByQ29tbWVudCsrO1xuICAgICAgICBpZih0eXBlb2Ygc3RhdGUuc0V4cHJRdW90ZSA9PSBcIm51bWJlclwiKSBzdGF0ZS5zRXhwclF1b3RlKys7XG5cbiAgICAgICAgcmV0dXJuVHlwZSA9IEJSQUNLRVQ7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiKVwiIHx8IGNoID09IFwiXVwiKSB7XG4gICAgICAgIHJldHVyblR5cGUgPSBCUkFDS0VUO1xuICAgICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgIT0gbnVsbCAmJiBzdGF0ZS5pbmRlbnRTdGFjay50eXBlID09IChjaCA9PSBcIilcIiA/IFwiKFwiIDogXCJbXCIpKSB7XG4gICAgICAgICAgcG9wU3RhY2soc3RhdGUpO1xuXG4gICAgICAgICAgaWYodHlwZW9mIHN0YXRlLnNFeHByQ29tbWVudCA9PSBcIm51bWJlclwiKXtcbiAgICAgICAgICAgIGlmKC0tc3RhdGUuc0V4cHJDb21tZW50ID09IDApe1xuICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDsgLy8gZmluYWwgY2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgIHN0YXRlLnNFeHByQ29tbWVudCA9IGZhbHNlOyAvLyB0dXJuIG9mZiBzLWV4cHIgY29tbWVudGluZyBtb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlID09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgaWYoLS1zdGF0ZS5zRXhwclF1b3RlID09IDApe1xuICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTsgLy8gZmluYWwgY2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgIHN0YXRlLnNFeHByUXVvdGUgPSBmYWxzZTsgLy8gdHVybiBvZmYgcy1leHByIHF1b3RlIG1vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19cXC0hJCUmKitcXC5cXC86PD0+P0BcXF5+XS8pO1xuXG4gICAgICAgIGlmIChrZXl3b3JkcyAmJiBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgICAgIHJldHVyblR5cGUgPSBCVUlMVElOO1xuICAgICAgICB9IGVsc2UgcmV0dXJuVHlwZSA9IFwidmFyaWFibGVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICh0eXBlb2Ygc3RhdGUuc0V4cHJDb21tZW50ID09IFwibnVtYmVyXCIpID8gQ09NTUVOVCA6ICgodHlwZW9mIHN0YXRlLnNFeHByUXVvdGUgPT0gXCJudW1iZXJcIikgPyBBVE9NIDogcmV0dXJuVHlwZSk7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCkgcmV0dXJuIHN0YXRlLmluZGVudGF0aW9uO1xuICAgIHJldHVybiBzdGF0ZS5pbmRlbnRTdGFjay5pbmRlbnQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY2xvc2VCcmFja2V0czoge2JyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgJ1wiJ119LFxuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIjs7XCJ9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/scheme.js\n"));

/***/ })

}]);