"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_erlang_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/erlang.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/erlang.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   erlang: function() { return /* binding */ erlang; }\n/* harmony export */ });\n/////////////////////////////////////////////////////////////////////////////\n// constants\n\nvar typeWords = [\n  \"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\n\nvar keywordWords = [\n  \"after\",\"begin\",\"catch\",\"case\",\"cond\",\"end\",\"fun\",\"if\",\n  \"let\",\"of\",\"query\",\"receive\",\"try\",\"when\"];\n\nvar separatorRE    = /[\\->,;]/;\nvar separatorWords = [\n  \"->\",\";\",\",\"];\n\nvar operatorAtomWords = [\n  \"and\",\"andalso\",\"band\",\"bnot\",\"bor\",\"bsl\",\"bsr\",\"bxor\",\n  \"div\",\"not\",\"or\",\"orelse\",\"rem\",\"xor\"];\n\nvar operatorSymbolRE    = /[\\+\\-\\*\\/<>=\\|:!]/;\nvar operatorSymbolWords = [\n  \"=\",\"+\",\"-\",\"*\",\"/\",\">\",\">=\",\"<\",\"=<\",\"=:=\",\"==\",\"=/=\",\"/=\",\"||\",\"<-\",\"!\"];\n\nvar openParenRE    = /[<\\(\\[\\{]/;\nvar openParenWords = [\n  \"<<\",\"(\",\"[\",\"{\"];\n\nvar closeParenRE    = /[>\\)\\]\\}]/;\nvar closeParenWords = [\n  \"}\",\"]\",\")\",\">>\"];\n\nvar guardWords = [\n  \"is_atom\",\"is_binary\",\"is_bitstring\",\"is_boolean\",\"is_float\",\n  \"is_function\",\"is_integer\",\"is_list\",\"is_number\",\"is_pid\",\n  \"is_port\",\"is_record\",\"is_reference\",\"is_tuple\",\n  \"atom\",\"binary\",\"bitstring\",\"boolean\",\"function\",\"integer\",\"list\",\n  \"number\",\"pid\",\"port\",\"record\",\"reference\",\"tuple\"];\n\nvar bifWords = [\n  \"abs\",\"adler32\",\"adler32_combine\",\"alive\",\"apply\",\"atom_to_binary\",\n  \"atom_to_list\",\"binary_to_atom\",\"binary_to_existing_atom\",\n  \"binary_to_list\",\"binary_to_term\",\"bit_size\",\"bitstring_to_list\",\n  \"byte_size\",\"check_process_code\",\"contact_binary\",\"crc32\",\n  \"crc32_combine\",\"date\",\"decode_packet\",\"delete_module\",\n  \"disconnect_node\",\"element\",\"erase\",\"exit\",\"float\",\"float_to_list\",\n  \"garbage_collect\",\"get\",\"get_keys\",\"group_leader\",\"halt\",\"hd\",\n  \"integer_to_list\",\"internal_bif\",\"iolist_size\",\"iolist_to_binary\",\n  \"is_alive\",\"is_atom\",\"is_binary\",\"is_bitstring\",\"is_boolean\",\n  \"is_float\",\"is_function\",\"is_integer\",\"is_list\",\"is_number\",\"is_pid\",\n  \"is_port\",\"is_process_alive\",\"is_record\",\"is_reference\",\"is_tuple\",\n  \"length\",\"link\",\"list_to_atom\",\"list_to_binary\",\"list_to_bitstring\",\n  \"list_to_existing_atom\",\"list_to_float\",\"list_to_integer\",\n  \"list_to_pid\",\"list_to_tuple\",\"load_module\",\"make_ref\",\"module_loaded\",\n  \"monitor_node\",\"node\",\"node_link\",\"node_unlink\",\"nodes\",\"notalive\",\n  \"now\",\"open_port\",\"pid_to_list\",\"port_close\",\"port_command\",\n  \"port_connect\",\"port_control\",\"pre_loaded\",\"process_flag\",\n  \"process_info\",\"processes\",\"purge_module\",\"put\",\"register\",\n  \"registered\",\"round\",\"self\",\"setelement\",\"size\",\"spawn\",\"spawn_link\",\n  \"spawn_monitor\",\"spawn_opt\",\"split_binary\",\"statistics\",\n  \"term_to_binary\",\"time\",\"throw\",\"tl\",\"trunc\",\"tuple_size\",\n  \"tuple_to_list\",\"unlink\",\"unregister\",\"whereis\"];\n\n// upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\nvar anumRE       = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\nvar escapesRE    =\n    /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n/////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\nfunction tokenizer(stream,state) {\n  // in multi-line string\n  if (state.in_string) {\n    state.in_string = (!doubleQuote(stream));\n    return rval(state,stream,\"string\");\n  }\n\n  // in multi-line atom\n  if (state.in_atom) {\n    state.in_atom = (!singleQuote(stream));\n    return rval(state,stream,\"atom\");\n  }\n\n  // whitespace\n  if (stream.eatSpace()) {\n    return rval(state,stream,\"whitespace\");\n  }\n\n  // attributes and type specs\n  if (!peekToken(state) &&\n      stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n    if (is_member(stream.current(),typeWords)) {\n      return rval(state,stream,\"type\");\n    }else{\n      return rval(state,stream,\"attribute\");\n    }\n  }\n\n  var ch = stream.next();\n\n  // comment\n  if (ch == '%') {\n    stream.skipToEnd();\n    return rval(state,stream,\"comment\");\n  }\n\n  // colon\n  if (ch == \":\") {\n    return rval(state,stream,\"colon\");\n  }\n\n  // macro\n  if (ch == '?') {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state,stream,\"macro\");\n  }\n\n  // record\n  if (ch == \"#\") {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state,stream,\"record\");\n  }\n\n  // dollar escape\n  if (ch == \"$\") {\n    if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n      return rval(state,stream,\"error\");\n    }\n    return rval(state,stream,\"number\");\n  }\n\n  // dot\n  if (ch == \".\") {\n    return rval(state,stream,\"dot\");\n  }\n\n  // quoted atom\n  if (ch == '\\'') {\n    if (!(state.in_atom = (!singleQuote(stream)))) {\n      if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/,true);\n        return rval(state,stream,\"fun\");      // 'f'/0 style fun\n      }\n      if (stream.match(/\\s*\\(/,false) || stream.match(/\\s*:/,false)) {\n        return rval(state,stream,\"function\");\n      }\n    }\n    return rval(state,stream,\"atom\");\n  }\n\n  // string\n  if (ch == '\"') {\n    state.in_string = (!doubleQuote(stream));\n    return rval(state,stream,\"string\");\n  }\n\n  // variable\n  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    return rval(state,stream,\"variable\");\n  }\n\n  // atom/keyword/BIF/function\n  if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n    stream.eatWhile(anumRE);\n\n    if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n      stream.match(/\\s*\\/\\s*[0-9]/,true);\n      return rval(state,stream,\"fun\");      // f/0 style fun\n    }\n\n    var w = stream.current();\n\n    if (is_member(w,keywordWords)) {\n      return rval(state,stream,\"keyword\");\n    }else if (is_member(w,operatorAtomWords)) {\n      return rval(state,stream,\"operator\");\n    }else if (stream.match(/\\s*\\(/,false)) {\n      // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n      if (is_member(w,bifWords) &&\n          ((peekToken(state).token != \":\") ||\n           (peekToken(state,2).token == \"erlang\"))) {\n        return rval(state,stream,\"builtin\");\n      }else if (is_member(w,guardWords)) {\n        return rval(state,stream,\"guard\");\n      }else{\n        return rval(state,stream,\"function\");\n      }\n    }else if (lookahead(stream) == \":\") {\n      if (w == \"erlang\") {\n        return rval(state,stream,\"builtin\");\n      } else {\n        return rval(state,stream,\"function\");\n      }\n    }else if (is_member(w,[\"true\",\"false\"])) {\n      return rval(state,stream,\"boolean\");\n    }else{\n      return rval(state,stream,\"atom\");\n    }\n  }\n\n  // number\n  var digitRE      = /[0-9]/;\n  var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int\n  if (digitRE.test(ch)) {\n    stream.eatWhile(digitRE);\n    if (stream.eat('#')) {                // 36#aZ  style integer\n      if (!stream.eatWhile(radixRE)) {\n        stream.backUp(1);                 //\"36#\" - syntax error\n      }\n    } else if (stream.eat('.')) {       // float\n      if (!stream.eatWhile(digitRE)) {\n        stream.backUp(1);        // \"3.\" - probably end of function\n      } else {\n        if (stream.eat(/[eE]/)) {        // float with exponent\n          if (stream.eat(/[-+]/)) {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(2);            // \"2e-\" - syntax error\n            }\n          } else {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(1);            // \"2e\" - syntax error\n            }\n          }\n        }\n      }\n    }\n    return rval(state,stream,\"number\");   // normal integer\n  }\n\n  // open parens\n  if (nongreedy(stream,openParenRE,openParenWords)) {\n    return rval(state,stream,\"open_paren\");\n  }\n\n  // close parens\n  if (nongreedy(stream,closeParenRE,closeParenWords)) {\n    return rval(state,stream,\"close_paren\");\n  }\n\n  // separators\n  if (greedy(stream,separatorRE,separatorWords)) {\n    return rval(state,stream,\"separator\");\n  }\n\n  // operators\n  if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {\n    return rval(state,stream,\"operator\");\n  }\n\n  return rval(state,stream,null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// utilities\nfunction nongreedy(stream,re,words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    stream.backUp(1);\n    while (re.test(stream.peek())) {\n      stream.next();\n      if (is_member(stream.current(),words)) {\n        return true;\n      }\n    }\n    stream.backUp(stream.current().length-1);\n  }\n  return false;\n}\n\nfunction greedy(stream,re,words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    while (re.test(stream.peek())) {\n      stream.next();\n    }\n    while (0 < stream.current().length) {\n      if (is_member(stream.current(),words)) {\n        return true;\n      }else{\n        stream.backUp(1);\n      }\n    }\n    stream.next();\n  }\n  return false;\n}\n\nfunction doubleQuote(stream) {\n  return quote(stream, '\"', '\\\\');\n}\n\nfunction singleQuote(stream) {\n  return quote(stream,'\\'','\\\\');\n}\n\nfunction quote(stream,quoteChar,escapeChar) {\n  while (!stream.eol()) {\n    var ch = stream.next();\n    if (ch == quoteChar) {\n      return true;\n    }else if (ch == escapeChar) {\n      stream.next();\n    }\n  }\n  return false;\n}\n\nfunction lookahead(stream) {\n  var m = stream.match(/^\\s*([^\\s%])/, false)\n  return m ? m[1] : \"\";\n}\n\nfunction is_member(element,list) {\n  return (-1 < list.indexOf(element));\n}\n\nfunction rval(state,stream,type) {\n\n  // parse stack\n  pushToken(state,realToken(type,stream));\n\n  // map erlang token type to CodeMirror style class\n  //     erlang             -> CodeMirror tag\n  switch (type) {\n  case \"atom\":        return \"atom\";\n  case \"attribute\":   return \"attribute\";\n  case \"boolean\":     return \"atom\";\n  case \"builtin\":     return \"builtin\";\n  case \"close_paren\": return null;\n  case \"colon\":       return null;\n  case \"comment\":     return \"comment\";\n  case \"dot\":         return null;\n  case \"error\":       return \"error\";\n  case \"fun\":         return \"meta\";\n  case \"function\":    return \"tag\";\n  case \"guard\":       return \"property\";\n  case \"keyword\":     return \"keyword\";\n  case \"macro\":       return \"macroName\";\n  case \"number\":      return \"number\";\n  case \"open_paren\":  return null;\n  case \"operator\":    return \"operator\";\n  case \"record\":      return \"bracket\";\n  case \"separator\":   return null;\n  case \"string\":      return \"string\";\n  case \"type\":        return \"def\";\n  case \"variable\":    return \"variable\";\n  default:            return null;\n  }\n}\n\nfunction aToken(tok,col,ind,typ) {\n  return {token:  tok,\n          column: col,\n          indent: ind,\n          type:   typ};\n}\n\nfunction realToken(type,stream) {\n  return aToken(stream.current(),\n                stream.column(),\n                stream.indentation(),\n                type);\n}\n\nfunction fakeToken(type) {\n  return aToken(type,0,0,type);\n}\n\nfunction peekToken(state,depth) {\n  var len = state.tokenStack.length;\n  var dep = (depth ? depth : 1);\n\n  if (len < dep) {\n    return false;\n  }else{\n    return state.tokenStack[len-dep];\n  }\n}\n\nfunction pushToken(state,token) {\n\n  if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n    state.tokenStack = maybe_drop_pre(state.tokenStack,token);\n    state.tokenStack = maybe_drop_post(state.tokenStack);\n  }\n}\n\nfunction maybe_drop_pre(s,token) {\n  var last = s.length-1;\n\n  if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n    s.pop();\n  }else if (0 < last && s[last].type === \"group\") {\n    s.pop();\n    s.push(token);\n  }else{\n    s.push(token);\n  }\n  return s;\n}\n\nfunction maybe_drop_post(s) {\n  if (!s.length) return s\n  var last = s.length-1;\n\n  if (s[last].type === \"dot\") {\n    return [];\n  }\n  if (last > 1 && s[last].type === \"fun\" && s[last-1].token === \"fun\") {\n    return s.slice(0,last-1);\n  }\n  switch (s[last].token) {\n  case \"}\":    return d(s,{g:[\"{\"]});\n  case \"]\":    return d(s,{i:[\"[\"]});\n  case \")\":    return d(s,{i:[\"(\"]});\n  case \">>\":   return d(s,{i:[\"<<\"]});\n  case \"end\":  return d(s,{i:[\"begin\",\"case\",\"fun\",\"if\",\"receive\",\"try\"]});\n  case \",\":    return d(s,{e:[\"begin\",\"try\",\"when\",\"->\",\n                              \",\",\"(\",\"[\",\"{\",\"<<\"]});\n  case \"->\":   return d(s,{r:[\"when\"],\n                           m:[\"try\",\"if\",\"case\",\"receive\"]});\n  case \";\":    return d(s,{E:[\"case\",\"fun\",\"if\",\"receive\",\"try\",\"when\"]});\n  case \"catch\":return d(s,{e:[\"try\"]});\n  case \"of\":   return d(s,{e:[\"case\"]});\n  case \"after\":return d(s,{e:[\"receive\",\"try\"]});\n  default:     return s;\n  }\n}\n\nfunction d(stack,tt) {\n  // stack is a stack of Token objects.\n  // tt is an object; {type:tokens}\n  // type is a char, tokens is a list of token strings.\n  // The function returns (possibly truncated) stack.\n  // It will descend the stack, looking for a Token such that Token.token\n  //  is a member of tokens. If it does not find that, it will normally (but\n  //  see \"E\" below) return stack. If it does find a match, it will remove\n  //  all the Tokens between the top and the matched Token.\n  // If type is \"m\", that is all it does.\n  // If type is \"i\", it will also remove the matched Token and the top Token.\n  // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n  // If type is \"r\", it will remove the matched Token, but not the top Token.\n  // If type is \"e\", it will keep the matched Token but not the top Token.\n  // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n  //  in which case it will return an empty stack.\n\n  for (var type in tt) {\n    var len = stack.length-1;\n    var tokens = tt[type];\n    for (var i = len-1; -1 < i ; i--) {\n      if (is_member(stack[i].token,tokens)) {\n        var ss = stack.slice(0,i);\n        switch (type) {\n        case \"m\": return ss.concat(stack[i]).concat(stack[len]);\n        case \"r\": return ss.concat(stack[len]);\n        case \"i\": return ss;\n        case \"g\": return ss.concat(fakeToken(\"group\"));\n        case \"E\": return ss.concat(stack[i]);\n        case \"e\": return ss.concat(stack[i]);\n        }\n      }\n    }\n  }\n  return (type == \"E\" ? [] : stack);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// indenter\n\nfunction indenter(state, textAfter, cx) {\n  var t;\n  var wordAfter = wordafter(textAfter);\n  var currT = peekToken(state,1);\n  var prevT = peekToken(state,2);\n\n  if (state.in_string || state.in_atom) {\n    return null;\n  }else if (!prevT) {\n    return 0;\n  }else if (currT.token == \"when\") {\n    return currT.column + cx.unit;\n  }else if (wordAfter === \"when\" && prevT.type === \"function\") {\n    return prevT.indent+cx.unit;\n  }else if (wordAfter === \"(\" && currT.token === \"fun\") {\n    return  currT.column+3;\n  }else if (wordAfter === \"catch\" && (t = getToken(state,[\"try\"]))) {\n    return t.column;\n  }else if (is_member(wordAfter,[\"end\",\"after\",\"of\"])) {\n    t = getToken(state,[\"begin\",\"case\",\"fun\",\"if\",\"receive\",\"try\"]);\n    return t ? t.column : null;\n  }else if (is_member(wordAfter,closeParenWords)) {\n    t = getToken(state,openParenWords);\n    return t ? t.column : null;\n  }else if (is_member(currT.token,[\",\",\"|\",\"||\"]) ||\n            is_member(wordAfter,[\",\",\"|\",\"||\"])) {\n    t = postcommaToken(state);\n    return t ? t.column+t.token.length : cx.unit;\n  }else if (currT.token == \"->\") {\n    if (is_member(prevT.token, [\"receive\",\"case\",\"if\",\"try\"])) {\n      return prevT.column+cx.unit+cx.unit;\n    }else{\n      return prevT.column+cx.unit;\n    }\n  }else if (is_member(currT.token,openParenWords)) {\n    return currT.column+currT.token.length;\n  }else{\n    t = defaultToken(state);\n    return truthy(t) ? t.column+cx.unit : 0;\n  }\n}\n\nfunction wordafter(str) {\n  var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n\n  return truthy(m) && (m.index === 0) ? m[0] : \"\";\n}\n\nfunction postcommaToken(state) {\n  var objs = state.tokenStack.slice(0,-1);\n  var i = getTokenIndex(objs,\"type\",[\"open_paren\"]);\n\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction defaultToken(state) {\n  var objs = state.tokenStack;\n  var stop = getTokenIndex(objs,\"type\",[\"open_paren\",\"separator\",\"keyword\"]);\n  var oper = getTokenIndex(objs,\"type\",[\"operator\"]);\n\n  if (truthy(stop) && truthy(oper) && stop < oper) {\n    return objs[stop+1];\n  } else if (truthy(stop)) {\n    return objs[stop];\n  } else {\n    return false;\n  }\n}\n\nfunction getToken(state,tokens) {\n  var objs = state.tokenStack;\n  var i = getTokenIndex(objs,\"token\",tokens);\n\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction getTokenIndex(objs,propname,propvals) {\n\n  for (var i = objs.length-1; -1 < i ; i--) {\n    if (is_member(objs[i][propname],propvals)) {\n      return i;\n    }\n  }\n  return false;\n}\n\nfunction truthy(x) {\n  return (x !== false) && (x != null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\nconst erlang = {\n  name: \"erlang\",\n  startState() {\n    return {tokenStack: [],\n            in_string:  false,\n            in_atom:    false};\n  },\n\n  token: tokenizer,\n\n  indent: indenter,\n\n  languageData: {\n    commentTokens: {line: \"%\"}\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9lcmxhbmcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBLGlCQUFpQjs7QUFFakIsK0JBQStCO0FBQy9CO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSSx5Q0FBeUMsRUFBRSxHQUFHLGFBQWE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsTUFBTSxrQ0FBa0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0JBQWtCLEtBQUssR0FBRztBQUNuQywyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsU0FBUztBQUNwQywyQkFBMkIsOENBQThDO0FBQ3pFLDJCQUEyQjtBQUMzQiw0Q0FBNEMsUUFBUTtBQUNwRCwyQkFBMkI7QUFDM0IsMkRBQTJEO0FBQzNELFNBQVMsa0JBQWtCLDZDQUE2QztBQUN4RSwyQkFBMkIsVUFBVTtBQUNyQywyQkFBMkIsV0FBVztBQUN0QywyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2VybGFuZy5qcz85ZDJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjb25zdGFudHNcblxudmFyIHR5cGVXb3JkcyA9IFtcbiAgXCItdHlwZVwiLCBcIi1zcGVjXCIsIFwiLWV4cG9ydF90eXBlXCIsIFwiLW9wYXF1ZVwiXTtcblxudmFyIGtleXdvcmRXb3JkcyA9IFtcbiAgXCJhZnRlclwiLFwiYmVnaW5cIixcImNhdGNoXCIsXCJjYXNlXCIsXCJjb25kXCIsXCJlbmRcIixcImZ1blwiLFwiaWZcIixcbiAgXCJsZXRcIixcIm9mXCIsXCJxdWVyeVwiLFwicmVjZWl2ZVwiLFwidHJ5XCIsXCJ3aGVuXCJdO1xuXG52YXIgc2VwYXJhdG9yUkUgICAgPSAvW1xcLT4sO10vO1xudmFyIHNlcGFyYXRvcldvcmRzID0gW1xuICBcIi0+XCIsXCI7XCIsXCIsXCJdO1xuXG52YXIgb3BlcmF0b3JBdG9tV29yZHMgPSBbXG4gIFwiYW5kXCIsXCJhbmRhbHNvXCIsXCJiYW5kXCIsXCJibm90XCIsXCJib3JcIixcImJzbFwiLFwiYnNyXCIsXCJieG9yXCIsXG4gIFwiZGl2XCIsXCJub3RcIixcIm9yXCIsXCJvcmVsc2VcIixcInJlbVwiLFwieG9yXCJdO1xuXG52YXIgb3BlcmF0b3JTeW1ib2xSRSAgICA9IC9bXFwrXFwtXFwqXFwvPD49XFx8OiFdLztcbnZhciBvcGVyYXRvclN5bWJvbFdvcmRzID0gW1xuICBcIj1cIixcIitcIixcIi1cIixcIipcIixcIi9cIixcIj5cIixcIj49XCIsXCI8XCIsXCI9PFwiLFwiPTo9XCIsXCI9PVwiLFwiPS89XCIsXCIvPVwiLFwifHxcIixcIjwtXCIsXCIhXCJdO1xuXG52YXIgb3BlblBhcmVuUkUgICAgPSAvWzxcXChcXFtcXHtdLztcbnZhciBvcGVuUGFyZW5Xb3JkcyA9IFtcbiAgXCI8PFwiLFwiKFwiLFwiW1wiLFwie1wiXTtcblxudmFyIGNsb3NlUGFyZW5SRSAgICA9IC9bPlxcKVxcXVxcfV0vO1xudmFyIGNsb3NlUGFyZW5Xb3JkcyA9IFtcbiAgXCJ9XCIsXCJdXCIsXCIpXCIsXCI+PlwiXTtcblxudmFyIGd1YXJkV29yZHMgPSBbXG4gIFwiaXNfYXRvbVwiLFwiaXNfYmluYXJ5XCIsXCJpc19iaXRzdHJpbmdcIixcImlzX2Jvb2xlYW5cIixcImlzX2Zsb2F0XCIsXG4gIFwiaXNfZnVuY3Rpb25cIixcImlzX2ludGVnZXJcIixcImlzX2xpc3RcIixcImlzX251bWJlclwiLFwiaXNfcGlkXCIsXG4gIFwiaXNfcG9ydFwiLFwiaXNfcmVjb3JkXCIsXCJpc19yZWZlcmVuY2VcIixcImlzX3R1cGxlXCIsXG4gIFwiYXRvbVwiLFwiYmluYXJ5XCIsXCJiaXRzdHJpbmdcIixcImJvb2xlYW5cIixcImZ1bmN0aW9uXCIsXCJpbnRlZ2VyXCIsXCJsaXN0XCIsXG4gIFwibnVtYmVyXCIsXCJwaWRcIixcInBvcnRcIixcInJlY29yZFwiLFwicmVmZXJlbmNlXCIsXCJ0dXBsZVwiXTtcblxudmFyIGJpZldvcmRzID0gW1xuICBcImFic1wiLFwiYWRsZXIzMlwiLFwiYWRsZXIzMl9jb21iaW5lXCIsXCJhbGl2ZVwiLFwiYXBwbHlcIixcImF0b21fdG9fYmluYXJ5XCIsXG4gIFwiYXRvbV90b19saXN0XCIsXCJiaW5hcnlfdG9fYXRvbVwiLFwiYmluYXJ5X3RvX2V4aXN0aW5nX2F0b21cIixcbiAgXCJiaW5hcnlfdG9fbGlzdFwiLFwiYmluYXJ5X3RvX3Rlcm1cIixcImJpdF9zaXplXCIsXCJiaXRzdHJpbmdfdG9fbGlzdFwiLFxuICBcImJ5dGVfc2l6ZVwiLFwiY2hlY2tfcHJvY2Vzc19jb2RlXCIsXCJjb250YWN0X2JpbmFyeVwiLFwiY3JjMzJcIixcbiAgXCJjcmMzMl9jb21iaW5lXCIsXCJkYXRlXCIsXCJkZWNvZGVfcGFja2V0XCIsXCJkZWxldGVfbW9kdWxlXCIsXG4gIFwiZGlzY29ubmVjdF9ub2RlXCIsXCJlbGVtZW50XCIsXCJlcmFzZVwiLFwiZXhpdFwiLFwiZmxvYXRcIixcImZsb2F0X3RvX2xpc3RcIixcbiAgXCJnYXJiYWdlX2NvbGxlY3RcIixcImdldFwiLFwiZ2V0X2tleXNcIixcImdyb3VwX2xlYWRlclwiLFwiaGFsdFwiLFwiaGRcIixcbiAgXCJpbnRlZ2VyX3RvX2xpc3RcIixcImludGVybmFsX2JpZlwiLFwiaW9saXN0X3NpemVcIixcImlvbGlzdF90b19iaW5hcnlcIixcbiAgXCJpc19hbGl2ZVwiLFwiaXNfYXRvbVwiLFwiaXNfYmluYXJ5XCIsXCJpc19iaXRzdHJpbmdcIixcImlzX2Jvb2xlYW5cIixcbiAgXCJpc19mbG9hdFwiLFwiaXNfZnVuY3Rpb25cIixcImlzX2ludGVnZXJcIixcImlzX2xpc3RcIixcImlzX251bWJlclwiLFwiaXNfcGlkXCIsXG4gIFwiaXNfcG9ydFwiLFwiaXNfcHJvY2Vzc19hbGl2ZVwiLFwiaXNfcmVjb3JkXCIsXCJpc19yZWZlcmVuY2VcIixcImlzX3R1cGxlXCIsXG4gIFwibGVuZ3RoXCIsXCJsaW5rXCIsXCJsaXN0X3RvX2F0b21cIixcImxpc3RfdG9fYmluYXJ5XCIsXCJsaXN0X3RvX2JpdHN0cmluZ1wiLFxuICBcImxpc3RfdG9fZXhpc3RpbmdfYXRvbVwiLFwibGlzdF90b19mbG9hdFwiLFwibGlzdF90b19pbnRlZ2VyXCIsXG4gIFwibGlzdF90b19waWRcIixcImxpc3RfdG9fdHVwbGVcIixcImxvYWRfbW9kdWxlXCIsXCJtYWtlX3JlZlwiLFwibW9kdWxlX2xvYWRlZFwiLFxuICBcIm1vbml0b3Jfbm9kZVwiLFwibm9kZVwiLFwibm9kZV9saW5rXCIsXCJub2RlX3VubGlua1wiLFwibm9kZXNcIixcIm5vdGFsaXZlXCIsXG4gIFwibm93XCIsXCJvcGVuX3BvcnRcIixcInBpZF90b19saXN0XCIsXCJwb3J0X2Nsb3NlXCIsXCJwb3J0X2NvbW1hbmRcIixcbiAgXCJwb3J0X2Nvbm5lY3RcIixcInBvcnRfY29udHJvbFwiLFwicHJlX2xvYWRlZFwiLFwicHJvY2Vzc19mbGFnXCIsXG4gIFwicHJvY2Vzc19pbmZvXCIsXCJwcm9jZXNzZXNcIixcInB1cmdlX21vZHVsZVwiLFwicHV0XCIsXCJyZWdpc3RlclwiLFxuICBcInJlZ2lzdGVyZWRcIixcInJvdW5kXCIsXCJzZWxmXCIsXCJzZXRlbGVtZW50XCIsXCJzaXplXCIsXCJzcGF3blwiLFwic3Bhd25fbGlua1wiLFxuICBcInNwYXduX21vbml0b3JcIixcInNwYXduX29wdFwiLFwic3BsaXRfYmluYXJ5XCIsXCJzdGF0aXN0aWNzXCIsXG4gIFwidGVybV90b19iaW5hcnlcIixcInRpbWVcIixcInRocm93XCIsXCJ0bFwiLFwidHJ1bmNcIixcInR1cGxlX3NpemVcIixcbiAgXCJ0dXBsZV90b19saXN0XCIsXCJ1bmxpbmtcIixcInVucmVnaXN0ZXJcIixcIndoZXJlaXNcIl07XG5cbi8vIHVwcGVyIGNhc2U6IFtBLVpdIFvDmC3Dnl0gW8OALcOWXVxuLy8gbG93ZXIgY2FzZTogW2Etel0gW8OfLcO2XSBbw7gtw79dXG52YXIgYW51bVJFICAgICAgID0gL1tcXHdAw5gtw57DgC3DlsOfLcO2w7gtw79dLztcbnZhciBlc2NhcGVzUkUgICAgPVxuICAgIC9bMC03XXsxLDN9fFtiZGVmbnJzdHZcXFxcXCInXXxcXF5bYS16QS1aXXx4WzAtOWEtekEtWl17Mn18eHtbMC05YS16QS1aXSt9LztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHRva2VuaXplclxuXG5mdW5jdGlvbiB0b2tlbml6ZXIoc3RyZWFtLHN0YXRlKSB7XG4gIC8vIGluIG11bHRpLWxpbmUgc3RyaW5nXG4gIGlmIChzdGF0ZS5pbl9zdHJpbmcpIHtcbiAgICBzdGF0ZS5pbl9zdHJpbmcgPSAoIWRvdWJsZVF1b3RlKHN0cmVhbSkpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInN0cmluZ1wiKTtcbiAgfVxuXG4gIC8vIGluIG11bHRpLWxpbmUgYXRvbVxuICBpZiAoc3RhdGUuaW5fYXRvbSkge1xuICAgIHN0YXRlLmluX2F0b20gPSAoIXNpbmdsZVF1b3RlKHN0cmVhbSkpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gIH1cblxuICAvLyB3aGl0ZXNwYWNlXG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIndoaXRlc3BhY2VcIik7XG4gIH1cblxuICAvLyBhdHRyaWJ1dGVzIGFuZCB0eXBlIHNwZWNzXG4gIGlmICghcGVla1Rva2VuKHN0YXRlKSAmJlxuICAgICAgc3RyZWFtLm1hdGNoKC8tXFxzKlthLXrDny3DtsO4LcO/XVtcXHfDmC3DnsOALcOWw58tw7bDuC3Dv10qLykpIHtcbiAgICBpZiAoaXNfbWVtYmVyKHN0cmVhbS5jdXJyZW50KCksdHlwZVdvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwidHlwZVwiKTtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0dHJpYnV0ZVwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gIC8vIGNvbW1lbnRcbiAgaWYgKGNoID09ICclJykge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJjb21tZW50XCIpO1xuICB9XG5cbiAgLy8gY29sb25cbiAgaWYgKGNoID09IFwiOlwiKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiY29sb25cIik7XG4gIH1cblxuICAvLyBtYWNyb1xuICBpZiAoY2ggPT0gJz8nKSB7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGFudW1SRSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwibWFjcm9cIik7XG4gIH1cblxuICAvLyByZWNvcmRcbiAgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGFudW1SRSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwicmVjb3JkXCIpO1xuICB9XG5cbiAgLy8gZG9sbGFyIGVzY2FwZVxuICBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICBpZiAoc3RyZWFtLm5leHQoKSA9PSBcIlxcXFxcIiAmJiAhc3RyZWFtLm1hdGNoKGVzY2FwZXNSRSkpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImVycm9yXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJudW1iZXJcIik7XG4gIH1cblxuICAvLyBkb3RcbiAgaWYgKGNoID09IFwiLlwiKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZG90XCIpO1xuICB9XG5cbiAgLy8gcXVvdGVkIGF0b21cbiAgaWYgKGNoID09ICdcXCcnKSB7XG4gICAgaWYgKCEoc3RhdGUuaW5fYXRvbSA9ICghc2luZ2xlUXVvdGUoc3RyZWFtKSkpKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwvXFxzKlswLTldLyxmYWxzZSkpIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9cXHMqXFwvXFxzKlswLTldLyx0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuXCIpOyAgICAgIC8vICdmJy8wIHN0eWxlIGZ1blxuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcKC8sZmFsc2UpIHx8IHN0cmVhbS5tYXRjaCgvXFxzKjovLGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYXRvbVwiKTtcbiAgfVxuXG4gIC8vIHN0cmluZ1xuICBpZiAoY2ggPT0gJ1wiJykge1xuICAgIHN0YXRlLmluX3N0cmluZyA9ICghZG91YmxlUXVvdGUoc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwic3RyaW5nXCIpO1xuICB9XG5cbiAgLy8gdmFyaWFibGVcbiAgaWYgKC9bQS1aX8OYLcOew4Atw5ZdLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZShhbnVtUkUpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInZhcmlhYmxlXCIpO1xuICB9XG5cbiAgLy8gYXRvbS9rZXl3b3JkL0JJRi9mdW5jdGlvblxuICBpZiAoL1thLXpfw58tw7bDuC3Dv10vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGFudW1SRSk7XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwvXFxzKlswLTldLyxmYWxzZSkpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXFxzKlxcL1xccypbMC05XS8sdHJ1ZSk7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5cIik7ICAgICAgLy8gZi8wIHN0eWxlIGZ1blxuICAgIH1cblxuICAgIHZhciB3ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgIGlmIChpc19tZW1iZXIodyxrZXl3b3JkV29yZHMpKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJrZXl3b3JkXCIpO1xuICAgIH1lbHNlIGlmIChpc19tZW1iZXIodyxvcGVyYXRvckF0b21Xb3JkcykpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm9wZXJhdG9yXCIpO1xuICAgIH1lbHNlIGlmIChzdHJlYW0ubWF0Y2goL1xccypcXCgvLGZhbHNlKSkge1xuICAgICAgLy8gJ3B1dCcgYW5kICdlcmxhbmc6cHV0JyBhcmUgYmlmcywgJ2ZvbzpwdXQnIGlzIG5vdFxuICAgICAgaWYgKGlzX21lbWJlcih3LGJpZldvcmRzKSAmJlxuICAgICAgICAgICgocGVla1Rva2VuKHN0YXRlKS50b2tlbiAhPSBcIjpcIikgfHxcbiAgICAgICAgICAgKHBlZWtUb2tlbihzdGF0ZSwyKS50b2tlbiA9PSBcImVybGFuZ1wiKSkpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYnVpbHRpblwiKTtcbiAgICAgIH1lbHNlIGlmIChpc19tZW1iZXIodyxndWFyZFdvcmRzKSkge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJndWFyZFwiKTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAobG9va2FoZWFkKHN0cmVhbSkgPT0gXCI6XCIpIHtcbiAgICAgIGlmICh3ID09IFwiZXJsYW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYnVpbHRpblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmIChpc19tZW1iZXIodyxbXCJ0cnVlXCIsXCJmYWxzZVwiXSkpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImJvb2xlYW5cIik7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJhdG9tXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG51bWJlclxuICB2YXIgZGlnaXRSRSAgICAgID0gL1swLTldLztcbiAgdmFyIHJhZGl4UkUgICAgICA9IC9bMC05YS16QS1aXS87ICAgICAgICAgLy8gMzYjelogc3R5bGUgaW50XG4gIGlmIChkaWdpdFJFLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGRpZ2l0UkUpO1xuICAgIGlmIChzdHJlYW0uZWF0KCcjJykpIHsgICAgICAgICAgICAgICAgLy8gMzYjYVogIHN0eWxlIGludGVnZXJcbiAgICAgIGlmICghc3RyZWFtLmVhdFdoaWxlKHJhZGl4UkUpKSB7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7ICAgICAgICAgICAgICAgICAvL1wiMzYjXCIgLSBzeW50YXggZXJyb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoJy4nKSkgeyAgICAgICAvLyBmbG9hdFxuICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSkpIHtcbiAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgIC8vIFwiMy5cIiAtIHByb2JhYmx5IGVuZCBvZiBmdW5jdGlvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoL1tlRV0vKSkgeyAgICAgICAgLy8gZmxvYXQgd2l0aCBleHBvbmVudFxuICAgICAgICAgIGlmIChzdHJlYW0uZWF0KC9bLStdLykpIHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLmVhdFdoaWxlKGRpZ2l0UkUpKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMik7ICAgICAgICAgICAgLy8gXCIyZS1cIiAtIHN5bnRheCBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS5lYXRXaGlsZShkaWdpdFJFKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAgICAgIC8vIFwiMmVcIiAtIHN5bnRheCBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJudW1iZXJcIik7ICAgLy8gbm9ybWFsIGludGVnZXJcbiAgfVxuXG4gIC8vIG9wZW4gcGFyZW5zXG4gIGlmIChub25ncmVlZHkoc3RyZWFtLG9wZW5QYXJlblJFLG9wZW5QYXJlbldvcmRzKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm9wZW5fcGFyZW5cIik7XG4gIH1cblxuICAvLyBjbG9zZSBwYXJlbnNcbiAgaWYgKG5vbmdyZWVkeShzdHJlYW0sY2xvc2VQYXJlblJFLGNsb3NlUGFyZW5Xb3JkcykpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJjbG9zZV9wYXJlblwiKTtcbiAgfVxuXG4gIC8vIHNlcGFyYXRvcnNcbiAgaWYgKGdyZWVkeShzdHJlYW0sc2VwYXJhdG9yUkUsc2VwYXJhdG9yV29yZHMpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwic2VwYXJhdG9yXCIpO1xuICB9XG5cbiAgLy8gb3BlcmF0b3JzXG4gIGlmIChncmVlZHkoc3RyZWFtLG9wZXJhdG9yU3ltYm9sUkUsb3BlcmF0b3JTeW1ib2xXb3JkcykpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJvcGVyYXRvclwiKTtcbiAgfVxuXG4gIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxudWxsKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHV0aWxpdGllc1xuZnVuY3Rpb24gbm9uZ3JlZWR5KHN0cmVhbSxyZSx3b3Jkcykge1xuICBpZiAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggPT0gMSAmJiByZS50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB3aGlsZSAocmUudGVzdChzdHJlYW0ucGVlaygpKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChpc19tZW1iZXIoc3RyZWFtLmN1cnJlbnQoKSx3b3JkcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGgtMSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBncmVlZHkoc3RyZWFtLHJlLHdvcmRzKSB7XG4gIGlmIChzdHJlYW0uY3VycmVudCgpLmxlbmd0aCA9PSAxICYmIHJlLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICB3aGlsZSAocmUudGVzdChzdHJlYW0ucGVlaygpKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgd2hpbGUgKDAgPCBzdHJlYW0uY3VycmVudCgpLmxlbmd0aCkge1xuICAgICAgaWYgKGlzX21lbWJlcihzdHJlYW0uY3VycmVudCgpLHdvcmRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1lbHNle1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0ubmV4dCgpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZG91YmxlUXVvdGUoc3RyZWFtKSB7XG4gIHJldHVybiBxdW90ZShzdHJlYW0sICdcIicsICdcXFxcJyk7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlKHN0cmVhbSkge1xuICByZXR1cm4gcXVvdGUoc3RyZWFtLCdcXCcnLCdcXFxcJyk7XG59XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmVhbSxxdW90ZUNoYXIsZXNjYXBlQ2hhcikge1xuICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09IHF1b3RlQ2hhcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWVsc2UgaWYgKGNoID09IGVzY2FwZUNoYXIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbG9va2FoZWFkKHN0cmVhbSkge1xuICB2YXIgbSA9IHN0cmVhbS5tYXRjaCgvXlxccyooW15cXHMlXSkvLCBmYWxzZSlcbiAgcmV0dXJuIG0gPyBtWzFdIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gaXNfbWVtYmVyKGVsZW1lbnQsbGlzdCkge1xuICByZXR1cm4gKC0xIDwgbGlzdC5pbmRleE9mKGVsZW1lbnQpKTtcbn1cblxuZnVuY3Rpb24gcnZhbChzdGF0ZSxzdHJlYW0sdHlwZSkge1xuXG4gIC8vIHBhcnNlIHN0YWNrXG4gIHB1c2hUb2tlbihzdGF0ZSxyZWFsVG9rZW4odHlwZSxzdHJlYW0pKTtcblxuICAvLyBtYXAgZXJsYW5nIHRva2VuIHR5cGUgdG8gQ29kZU1pcnJvciBzdHlsZSBjbGFzc1xuICAvLyAgICAgZXJsYW5nICAgICAgICAgICAgIC0+IENvZGVNaXJyb3IgdGFnXG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlIFwiYXRvbVwiOiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICBjYXNlIFwiYXR0cmlidXRlXCI6ICAgcmV0dXJuIFwiYXR0cmlidXRlXCI7XG4gIGNhc2UgXCJib29sZWFuXCI6ICAgICByZXR1cm4gXCJhdG9tXCI7XG4gIGNhc2UgXCJidWlsdGluXCI6ICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gIGNhc2UgXCJjbG9zZV9wYXJlblwiOiByZXR1cm4gbnVsbDtcbiAgY2FzZSBcImNvbG9uXCI6ICAgICAgIHJldHVybiBudWxsO1xuICBjYXNlIFwiY29tbWVudFwiOiAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICBjYXNlIFwiZG90XCI6ICAgICAgICAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJlcnJvclwiOiAgICAgICByZXR1cm4gXCJlcnJvclwiO1xuICBjYXNlIFwiZnVuXCI6ICAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICBjYXNlIFwiZnVuY3Rpb25cIjogICAgcmV0dXJuIFwidGFnXCI7XG4gIGNhc2UgXCJndWFyZFwiOiAgICAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICBjYXNlIFwia2V5d29yZFwiOiAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICBjYXNlIFwibWFjcm9cIjogICAgICAgcmV0dXJuIFwibWFjcm9OYW1lXCI7XG4gIGNhc2UgXCJudW1iZXJcIjogICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgY2FzZSBcIm9wZW5fcGFyZW5cIjogIHJldHVybiBudWxsO1xuICBjYXNlIFwib3BlcmF0b3JcIjogICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgY2FzZSBcInJlY29yZFwiOiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgY2FzZSBcInNlcGFyYXRvclwiOiAgIHJldHVybiBudWxsO1xuICBjYXNlIFwic3RyaW5nXCI6ICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIGNhc2UgXCJ0eXBlXCI6ICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgY2FzZSBcInZhcmlhYmxlXCI6ICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIGRlZmF1bHQ6ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gYVRva2VuKHRvayxjb2wsaW5kLHR5cCkge1xuICByZXR1cm4ge3Rva2VuOiAgdG9rLFxuICAgICAgICAgIGNvbHVtbjogY29sLFxuICAgICAgICAgIGluZGVudDogaW5kLFxuICAgICAgICAgIHR5cGU6ICAgdHlwfTtcbn1cblxuZnVuY3Rpb24gcmVhbFRva2VuKHR5cGUsc3RyZWFtKSB7XG4gIHJldHVybiBhVG9rZW4oc3RyZWFtLmN1cnJlbnQoKSxcbiAgICAgICAgICAgICAgICBzdHJlYW0uY29sdW1uKCksXG4gICAgICAgICAgICAgICAgc3RyZWFtLmluZGVudGF0aW9uKCksXG4gICAgICAgICAgICAgICAgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGZha2VUb2tlbih0eXBlKSB7XG4gIHJldHVybiBhVG9rZW4odHlwZSwwLDAsdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHBlZWtUb2tlbihzdGF0ZSxkZXB0aCkge1xuICB2YXIgbGVuID0gc3RhdGUudG9rZW5TdGFjay5sZW5ndGg7XG4gIHZhciBkZXAgPSAoZGVwdGggPyBkZXB0aCA6IDEpO1xuXG4gIGlmIChsZW4gPCBkZXApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1lbHNle1xuICAgIHJldHVybiBzdGF0ZS50b2tlblN0YWNrW2xlbi1kZXBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb2tlbihzdGF0ZSx0b2tlbikge1xuXG4gIGlmICghKHRva2VuLnR5cGUgPT0gXCJjb21tZW50XCIgfHwgdG9rZW4udHlwZSA9PSBcIndoaXRlc3BhY2VcIikpIHtcbiAgICBzdGF0ZS50b2tlblN0YWNrID0gbWF5YmVfZHJvcF9wcmUoc3RhdGUudG9rZW5TdGFjayx0b2tlbik7XG4gICAgc3RhdGUudG9rZW5TdGFjayA9IG1heWJlX2Ryb3BfcG9zdChzdGF0ZS50b2tlblN0YWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZV9kcm9wX3ByZShzLHRva2VuKSB7XG4gIHZhciBsYXN0ID0gcy5sZW5ndGgtMTtcblxuICBpZiAoMCA8IGxhc3QgJiYgc1tsYXN0XS50eXBlID09PSBcInJlY29yZFwiICYmIHRva2VuLnR5cGUgPT09IFwiZG90XCIpIHtcbiAgICBzLnBvcCgpO1xuICB9ZWxzZSBpZiAoMCA8IGxhc3QgJiYgc1tsYXN0XS50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICBzLnBvcCgpO1xuICAgIHMucHVzaCh0b2tlbik7XG4gIH1lbHNle1xuICAgIHMucHVzaCh0b2tlbik7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIG1heWJlX2Ryb3BfcG9zdChzKSB7XG4gIGlmICghcy5sZW5ndGgpIHJldHVybiBzXG4gIHZhciBsYXN0ID0gcy5sZW5ndGgtMTtcblxuICBpZiAoc1tsYXN0XS50eXBlID09PSBcImRvdFwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChsYXN0ID4gMSAmJiBzW2xhc3RdLnR5cGUgPT09IFwiZnVuXCIgJiYgc1tsYXN0LTFdLnRva2VuID09PSBcImZ1blwiKSB7XG4gICAgcmV0dXJuIHMuc2xpY2UoMCxsYXN0LTEpO1xuICB9XG4gIHN3aXRjaCAoc1tsYXN0XS50b2tlbikge1xuICBjYXNlIFwifVwiOiAgICByZXR1cm4gZChzLHtnOltcIntcIl19KTtcbiAgY2FzZSBcIl1cIjogICAgcmV0dXJuIGQocyx7aTpbXCJbXCJdfSk7XG4gIGNhc2UgXCIpXCI6ICAgIHJldHVybiBkKHMse2k6W1wiKFwiXX0pO1xuICBjYXNlIFwiPj5cIjogICByZXR1cm4gZChzLHtpOltcIjw8XCJdfSk7XG4gIGNhc2UgXCJlbmRcIjogIHJldHVybiBkKHMse2k6W1wiYmVnaW5cIixcImNhc2VcIixcImZ1blwiLFwiaWZcIixcInJlY2VpdmVcIixcInRyeVwiXX0pO1xuICBjYXNlIFwiLFwiOiAgICByZXR1cm4gZChzLHtlOltcImJlZ2luXCIsXCJ0cnlcIixcIndoZW5cIixcIi0+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcIixcIihcIixcIltcIixcIntcIixcIjw8XCJdfSk7XG4gIGNhc2UgXCItPlwiOiAgIHJldHVybiBkKHMse3I6W1wid2hlblwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG06W1widHJ5XCIsXCJpZlwiLFwiY2FzZVwiLFwicmVjZWl2ZVwiXX0pO1xuICBjYXNlIFwiO1wiOiAgICByZXR1cm4gZChzLHtFOltcImNhc2VcIixcImZ1blwiLFwiaWZcIixcInJlY2VpdmVcIixcInRyeVwiLFwid2hlblwiXX0pO1xuICBjYXNlIFwiY2F0Y2hcIjpyZXR1cm4gZChzLHtlOltcInRyeVwiXX0pO1xuICBjYXNlIFwib2ZcIjogICByZXR1cm4gZChzLHtlOltcImNhc2VcIl19KTtcbiAgY2FzZSBcImFmdGVyXCI6cmV0dXJuIGQocyx7ZTpbXCJyZWNlaXZlXCIsXCJ0cnlcIl19KTtcbiAgZGVmYXVsdDogICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGQoc3RhY2ssdHQpIHtcbiAgLy8gc3RhY2sgaXMgYSBzdGFjayBvZiBUb2tlbiBvYmplY3RzLlxuICAvLyB0dCBpcyBhbiBvYmplY3Q7IHt0eXBlOnRva2Vuc31cbiAgLy8gdHlwZSBpcyBhIGNoYXIsIHRva2VucyBpcyBhIGxpc3Qgb2YgdG9rZW4gc3RyaW5ncy5cbiAgLy8gVGhlIGZ1bmN0aW9uIHJldHVybnMgKHBvc3NpYmx5IHRydW5jYXRlZCkgc3RhY2suXG4gIC8vIEl0IHdpbGwgZGVzY2VuZCB0aGUgc3RhY2ssIGxvb2tpbmcgZm9yIGEgVG9rZW4gc3VjaCB0aGF0IFRva2VuLnRva2VuXG4gIC8vICBpcyBhIG1lbWJlciBvZiB0b2tlbnMuIElmIGl0IGRvZXMgbm90IGZpbmQgdGhhdCwgaXQgd2lsbCBub3JtYWxseSAoYnV0XG4gIC8vICBzZWUgXCJFXCIgYmVsb3cpIHJldHVybiBzdGFjay4gSWYgaXQgZG9lcyBmaW5kIGEgbWF0Y2gsIGl0IHdpbGwgcmVtb3ZlXG4gIC8vICBhbGwgdGhlIFRva2VucyBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZSBtYXRjaGVkIFRva2VuLlxuICAvLyBJZiB0eXBlIGlzIFwibVwiLCB0aGF0IGlzIGFsbCBpdCBkb2VzLlxuICAvLyBJZiB0eXBlIGlzIFwiaVwiLCBpdCB3aWxsIGFsc28gcmVtb3ZlIHRoZSBtYXRjaGVkIFRva2VuIGFuZCB0aGUgdG9wIFRva2VuLlxuICAvLyBJZiB0eXBlIGlzIFwiZ1wiLCBsaWtlIFwiaVwiLCBidXQgYWRkIGEgZmFrZSBcImdyb3VwXCIgdG9rZW4gYXQgdGhlIHRvcC5cbiAgLy8gSWYgdHlwZSBpcyBcInJcIiwgaXQgd2lsbCByZW1vdmUgdGhlIG1hdGNoZWQgVG9rZW4sIGJ1dCBub3QgdGhlIHRvcCBUb2tlbi5cbiAgLy8gSWYgdHlwZSBpcyBcImVcIiwgaXQgd2lsbCBrZWVwIHRoZSBtYXRjaGVkIFRva2VuIGJ1dCBub3QgdGhlIHRvcCBUb2tlbi5cbiAgLy8gSWYgdHlwZSBpcyBcIkVcIiwgaXQgYmVoYXZlcyBhcyBmb3IgdHlwZSBcImVcIiwgZXhjZXB0IGlmIHRoZXJlIGlzIG5vIG1hdGNoLFxuICAvLyAgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdGFjay5cblxuICBmb3IgKHZhciB0eXBlIGluIHR0KSB7XG4gICAgdmFyIGxlbiA9IHN0YWNrLmxlbmd0aC0xO1xuICAgIHZhciB0b2tlbnMgPSB0dFt0eXBlXTtcbiAgICBmb3IgKHZhciBpID0gbGVuLTE7IC0xIDwgaSA7IGktLSkge1xuICAgICAgaWYgKGlzX21lbWJlcihzdGFja1tpXS50b2tlbix0b2tlbnMpKSB7XG4gICAgICAgIHZhciBzcyA9IHN0YWNrLnNsaWNlKDAsaSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibVwiOiByZXR1cm4gc3MuY29uY2F0KHN0YWNrW2ldKS5jb25jYXQoc3RhY2tbbGVuXSk7XG4gICAgICAgIGNhc2UgXCJyXCI6IHJldHVybiBzcy5jb25jYXQoc3RhY2tbbGVuXSk7XG4gICAgICAgIGNhc2UgXCJpXCI6IHJldHVybiBzcztcbiAgICAgICAgY2FzZSBcImdcIjogcmV0dXJuIHNzLmNvbmNhdChmYWtlVG9rZW4oXCJncm91cFwiKSk7XG4gICAgICAgIGNhc2UgXCJFXCI6IHJldHVybiBzcy5jb25jYXQoc3RhY2tbaV0pO1xuICAgICAgICBjYXNlIFwiZVwiOiByZXR1cm4gc3MuY29uY2F0KHN0YWNrW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHR5cGUgPT0gXCJFXCIgPyBbXSA6IHN0YWNrKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGluZGVudGVyXG5cbmZ1bmN0aW9uIGluZGVudGVyKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gIHZhciB0O1xuICB2YXIgd29yZEFmdGVyID0gd29yZGFmdGVyKHRleHRBZnRlcik7XG4gIHZhciBjdXJyVCA9IHBlZWtUb2tlbihzdGF0ZSwxKTtcbiAgdmFyIHByZXZUID0gcGVla1Rva2VuKHN0YXRlLDIpO1xuXG4gIGlmIChzdGF0ZS5pbl9zdHJpbmcgfHwgc3RhdGUuaW5fYXRvbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9ZWxzZSBpZiAoIXByZXZUKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1lbHNlIGlmIChjdXJyVC50b2tlbiA9PSBcIndoZW5cIikge1xuICAgIHJldHVybiBjdXJyVC5jb2x1bW4gKyBjeC51bml0O1xuICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcIndoZW5cIiAmJiBwcmV2VC50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gcHJldlQuaW5kZW50K2N4LnVuaXQ7XG4gIH1lbHNlIGlmICh3b3JkQWZ0ZXIgPT09IFwiKFwiICYmIGN1cnJULnRva2VuID09PSBcImZ1blwiKSB7XG4gICAgcmV0dXJuICBjdXJyVC5jb2x1bW4rMztcbiAgfWVsc2UgaWYgKHdvcmRBZnRlciA9PT0gXCJjYXRjaFwiICYmICh0ID0gZ2V0VG9rZW4oc3RhdGUsW1widHJ5XCJdKSkpIHtcbiAgICByZXR1cm4gdC5jb2x1bW47XG4gIH1lbHNlIGlmIChpc19tZW1iZXIod29yZEFmdGVyLFtcImVuZFwiLFwiYWZ0ZXJcIixcIm9mXCJdKSkge1xuICAgIHQgPSBnZXRUb2tlbihzdGF0ZSxbXCJiZWdpblwiLFwiY2FzZVwiLFwiZnVuXCIsXCJpZlwiLFwicmVjZWl2ZVwiLFwidHJ5XCJdKTtcbiAgICByZXR1cm4gdCA/IHQuY29sdW1uIDogbnVsbDtcbiAgfWVsc2UgaWYgKGlzX21lbWJlcih3b3JkQWZ0ZXIsY2xvc2VQYXJlbldvcmRzKSkge1xuICAgIHQgPSBnZXRUb2tlbihzdGF0ZSxvcGVuUGFyZW5Xb3Jkcyk7XG4gICAgcmV0dXJuIHQgPyB0LmNvbHVtbiA6IG51bGw7XG4gIH1lbHNlIGlmIChpc19tZW1iZXIoY3VyclQudG9rZW4sW1wiLFwiLFwifFwiLFwifHxcIl0pIHx8XG4gICAgICAgICAgICBpc19tZW1iZXIod29yZEFmdGVyLFtcIixcIixcInxcIixcInx8XCJdKSkge1xuICAgIHQgPSBwb3N0Y29tbWFUb2tlbihzdGF0ZSk7XG4gICAgcmV0dXJuIHQgPyB0LmNvbHVtbit0LnRva2VuLmxlbmd0aCA6IGN4LnVuaXQ7XG4gIH1lbHNlIGlmIChjdXJyVC50b2tlbiA9PSBcIi0+XCIpIHtcbiAgICBpZiAoaXNfbWVtYmVyKHByZXZULnRva2VuLCBbXCJyZWNlaXZlXCIsXCJjYXNlXCIsXCJpZlwiLFwidHJ5XCJdKSkge1xuICAgICAgcmV0dXJuIHByZXZULmNvbHVtbitjeC51bml0K2N4LnVuaXQ7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gcHJldlQuY29sdW1uK2N4LnVuaXQ7XG4gICAgfVxuICB9ZWxzZSBpZiAoaXNfbWVtYmVyKGN1cnJULnRva2VuLG9wZW5QYXJlbldvcmRzKSkge1xuICAgIHJldHVybiBjdXJyVC5jb2x1bW4rY3VyclQudG9rZW4ubGVuZ3RoO1xuICB9ZWxzZXtcbiAgICB0ID0gZGVmYXVsdFRva2VuKHN0YXRlKTtcbiAgICByZXR1cm4gdHJ1dGh5KHQpID8gdC5jb2x1bW4rY3gudW5pdCA6IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gd29yZGFmdGVyKHN0cikge1xuICB2YXIgbSA9IHN0ci5tYXRjaCgvLHxbYS16XSt8XFx9fFxcXXxcXCl8Pj58XFx8K3xcXCgvKTtcblxuICByZXR1cm4gdHJ1dGh5KG0pICYmIChtLmluZGV4ID09PSAwKSA/IG1bMF0gOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBwb3N0Y29tbWFUb2tlbihzdGF0ZSkge1xuICB2YXIgb2JqcyA9IHN0YXRlLnRva2VuU3RhY2suc2xpY2UoMCwtMSk7XG4gIHZhciBpID0gZ2V0VG9rZW5JbmRleChvYmpzLFwidHlwZVwiLFtcIm9wZW5fcGFyZW5cIl0pO1xuXG4gIHJldHVybiB0cnV0aHkob2Jqc1tpXSkgPyBvYmpzW2ldIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb2tlbihzdGF0ZSkge1xuICB2YXIgb2JqcyA9IHN0YXRlLnRva2VuU3RhY2s7XG4gIHZhciBzdG9wID0gZ2V0VG9rZW5JbmRleChvYmpzLFwidHlwZVwiLFtcIm9wZW5fcGFyZW5cIixcInNlcGFyYXRvclwiLFwia2V5d29yZFwiXSk7XG4gIHZhciBvcGVyID0gZ2V0VG9rZW5JbmRleChvYmpzLFwidHlwZVwiLFtcIm9wZXJhdG9yXCJdKTtcblxuICBpZiAodHJ1dGh5KHN0b3ApICYmIHRydXRoeShvcGVyKSAmJiBzdG9wIDwgb3Blcikge1xuICAgIHJldHVybiBvYmpzW3N0b3ArMV07XG4gIH0gZWxzZSBpZiAodHJ1dGh5KHN0b3ApKSB7XG4gICAgcmV0dXJuIG9ianNbc3RvcF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRva2VuKHN0YXRlLHRva2Vucykge1xuICB2YXIgb2JqcyA9IHN0YXRlLnRva2VuU3RhY2s7XG4gIHZhciBpID0gZ2V0VG9rZW5JbmRleChvYmpzLFwidG9rZW5cIix0b2tlbnMpO1xuXG4gIHJldHVybiB0cnV0aHkob2Jqc1tpXSkgPyBvYmpzW2ldIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFRva2VuSW5kZXgob2Jqcyxwcm9wbmFtZSxwcm9wdmFscykge1xuXG4gIGZvciAodmFyIGkgPSBvYmpzLmxlbmd0aC0xOyAtMSA8IGkgOyBpLS0pIHtcbiAgICBpZiAoaXNfbWVtYmVyKG9ianNbaV1bcHJvcG5hbWVdLHByb3B2YWxzKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJ1dGh5KHgpIHtcbiAgcmV0dXJuICh4ICE9PSBmYWxzZSkgJiYgKHggIT0gbnVsbCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0aGlzIG9iamVjdCBkZWZpbmVzIHRoZSBtb2RlXG5cbmV4cG9ydCBjb25zdCBlcmxhbmcgPSB7XG4gIG5hbWU6IFwiZXJsYW5nXCIsXG4gIHN0YXJ0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHt0b2tlblN0YWNrOiBbXSxcbiAgICAgICAgICAgIGluX3N0cmluZzogIGZhbHNlLFxuICAgICAgICAgICAgaW5fYXRvbTogICAgZmFsc2V9O1xuICB9LFxuXG4gIHRva2VuOiB0b2tlbml6ZXIsXG5cbiAgaW5kZW50OiBpbmRlbnRlcixcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIlXCJ9XG4gIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/erlang.js\n"));

/***/ })

}]);