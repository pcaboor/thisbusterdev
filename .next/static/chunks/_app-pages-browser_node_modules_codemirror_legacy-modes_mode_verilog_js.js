"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_verilog_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/verilog.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/verilog.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tlv: function() { return /* binding */ tlv; },\n/* harmony export */   verilog: function() { return /* binding */ verilog; }\n/* harmony export */ });\nfunction mkVerilog(parserConfig) {\n\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n      \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n      \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n      \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n      \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n      \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n      \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n      \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n      \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n      \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n      \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n      \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n      \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n      \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n      \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n      \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n      \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n      \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n      \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n    name: \"verilog\",\n\n    startState: function(indentUnit) {\n      var state = {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\n                 (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter, cx) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);\n      else return ctx.indented + (closing ? 0 : cx.unit);\n    },\n\n    languageData: {\n      indentOnInput: buildElectricInputRegEx(),\n      commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n    }\n  };\n};\n\nconst verilog = mkVerilog({})\n\n// TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\nvar tlvIdentifierStyle = {\n  \"|\": \"link\",\n  \">\": \"property\",  // Should condition this off for > TLV 1c.\n  \"$\": \"variable\",\n  \"$$\": \"variable\",\n  \"?$\": \"qualifier\",\n  \"?*\": \"qualifier\",\n  \"-\": \"contentSeparator\",\n  \"/\": \"property\",\n  \"/-\": \"property\",\n  \"@\": \"variableName.special\",\n  \"@-\": \"variableName.special\",\n  \"@++\": \"variableName.special\",\n  \"@+=\": \"variableName.special\",\n  \"@+=-\": \"variableName.special\",\n  \"@--\": \"variableName.special\",\n  \"@-=\": \"variableName.special\",\n  \"%+\": \"tag\",\n  \"%-\": \"tag\",\n  \"%\": \"tag\",\n  \">>\": \"tag\",\n  \"<<\": \"tag\",\n  \"<>\": \"tag\",\n  \"#\": \"tag\",  // Need to choose a style for this.\n  \"^\": \"attribute\",\n  \"^^\": \"attribute\",\n  \"^!\": \"attribute\",\n  \"*\": \"variable\",\n  \"**\": \"variable\",\n  \"\\\\\": \"keyword\",\n  \"\\\"\": \"comment\"\n};\n\n// Lines starting with these characters define scope (result in indentation).\nvar tlvScopePrefixChars = {\n  \"/\": \"beh-hier\",\n  \">\": \"beh-hier\",\n  \"-\": \"phys-hier\",\n  \"|\": \"pipe\",\n  \"?\": \"when\",\n  \"@\": \"stage\",\n  \"\\\\\": \"keyword\"\n};\nvar tlvIndentUnit = 3;\nvar tlvTrackStatements = false;\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\nvar tlvLineIndentationMatch = /^[! ] */;\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\n\nconst tlv = mkVerilog({\n  hooks: {\n    electricInput: false,\n\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n    //   - M4 tokens\n    //   - TLV scope indentation\n    //   - Statement delimitation (enabled by tlvTrackStatements)\n    token: function(stream, state) {\n      var style = undefined;\n      var match;  // Return value of pattern matches.\n\n      // Set highlighting mode based on code region (TLV or SV).\n      if (stream.sol() && ! state.tlvInBlockComment) {\n        // Process region.\n        if (stream.peek() == '\\\\') {\n          style = \"def\";\n          stream.skipToEnd();\n          if (stream.string.match(/\\\\SV/)) {\n            state.tlvCodeActive = false;\n          } else if (stream.string.match(/\\\\TLV/)){\n            state.tlvCodeActive = true;\n          }\n        }\n        // Correct indentation in the face of a line prefix char.\n        if (state.tlvCodeActive && stream.pos == 0 &&\n            (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n          state.indented = match[0].length;\n        }\n\n        // Compute indentation state:\n        //   o Auto indentation on next line\n        //   o Indentation scope styles\n        var indented = state.indented;\n        var depth = indented / tlvIndentUnit;\n        if (depth <= state.tlvIndentationStyle.length) {\n          // not deeper than current scope\n\n          var blankline = stream.string.length == indented;\n          var chPos = depth * tlvIndentUnit;\n          if (chPos < stream.string.length) {\n            var bodyString = stream.string.slice(chPos);\n            var ch = bodyString[0];\n            if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                                            tlvIdentifierStyle[match[1]])) {\n              // This line begins scope.\n              // Next line gets indented one level.\n              indented += tlvIndentUnit;\n              // Style the next level of indentation (except non-region keyword identifiers,\n              //   which are statements themselves)\n              if (!(ch == \"\\\\\" && chPos > 0)) {\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                if (tlvTrackStatements) {state.statementComment = false;}\n                depth++;\n              }\n            }\n          }\n          // Clear out deeper indentation levels unless line is blank.\n          if (!blankline) {\n            while (state.tlvIndentationStyle.length > depth) {\n              state.tlvIndentationStyle.pop();\n            }\n          }\n        }\n        // Set next level of indentation.\n        state.tlvNextIndent = indented;\n      }\n\n      if (state.tlvCodeActive) {\n        // Highlight as TLV.\n\n        var beginStatement = false;\n        if (tlvTrackStatements) {\n          // This starts a statement if the position is at the scope level\n          // and we're not within a statement leading comment.\n          beginStatement =\n            (stream.peek() != \" \") &&   // not a space\n            (style === undefined) &&    // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n          (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n          if (beginStatement) {\n            if (state.statementComment) {\n              // statement already started by comment\n              beginStatement = false;\n            }\n            state.statementComment =\n              stream.match(tlvCommentMatch, false); // comment start\n          }\n        }\n\n        var match;\n        if (style !== undefined) {\n        } else if (state.tlvInBlockComment) {\n          // In a block comment.\n          if (stream.match(/^.*?\\*\\//)) {\n            // Exit block comment.\n            state.tlvInBlockComment = false;\n            if (tlvTrackStatements && !stream.eol()) {\n              // Anything after comment is assumed to be real statement content.\n              state.statementComment = false;\n            }\n          } else {\n            stream.skipToEnd();\n          }\n          style = \"comment\";\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n          // Start comment.\n          if (match[0] == \"//\") {\n            // Line comment.\n            stream.skipToEnd();\n          } else {\n            // Block comment.\n            state.tlvInBlockComment = true;\n          }\n          style = \"comment\";\n        } else if (match = stream.match(tlvIdentMatch)) {\n          // looks like an identifier (or identifier prefix)\n          var prefix = match[1];\n          var mnemonic = match[2];\n          if (// is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) &&\n              // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            (mnemonic.length > 0 || stream.eol())) {\n            style = tlvIdentifierStyle[prefix];\n          } else {\n            // Just swallow one character and try again.\n            // This enables subsequent identifier match with preceding symbol character, which\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n            //   comment start with preceding symbols.\n            stream.backUp(stream.current().length - 1);\n          }\n        } else if (stream.match(/^\\t+/)) {\n          // Highlight tabs, which are illegal.\n          style = \"invalid\";\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n          // [:], (), {}, ;.\n          style = \"meta\";\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n          // m4 pre proc\n          style = (match[1] == \"+\") ? \"keyword.special\" : \"keyword\";\n        } else if (stream.match(/^ +/)){\n          // Skip over spaces.\n          if (stream.eol()) {\n            // Trailing spaces.\n            style = \"error\";\n          }\n        } else if (stream.match(/^[\\w\\d_]+/)) {\n          // alpha-numeric token.\n          style = \"number\";\n        } else {\n          // Eat the next char w/ no formatting.\n          stream.next();\n        }\n      } else {\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n          // m4 pre proc\n          style = \"keyword\";\n        }\n      }\n      return style;\n    },\n\n    indent: function(state) {\n      return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n    },\n\n    startState: function(state) {\n      state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n      state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n      state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n      state.tlvInBlockComment = false;  // True inside /**/ comment.\n      if (tlvTrackStatements) {\n        state.statementComment = false;  // True inside a statement's header comment.\n      }\n    }\n\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS92ZXJpbG9nLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QywyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUIsOENBQThDO0FBQzlDLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFTyw0QkFBNEI7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVLCtCQUErQixLQUFLO0FBQzlDLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsdUNBQXVDO0FBQ3ZDLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsd0NBQXdDO0FBQ3hDO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS92ZXJpbG9nLmpzPzBkMGIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWtWZXJpbG9nKHBhcnNlckNvbmZpZykge1xuXG4gIHZhciBzdGF0ZW1lbnRJbmRlbnRVbml0ID0gcGFyc2VyQ29uZmlnLnN0YXRlbWVudEluZGVudFVuaXQsXG4gICAgICBkb250QWxpZ25DYWxscyA9IHBhcnNlckNvbmZpZy5kb250QWxpZ25DYWxscyxcbiAgICAgIG5vSW5kZW50S2V5d29yZHMgPSBwYXJzZXJDb25maWcubm9JbmRlbnRLZXl3b3JkcyB8fCBbXSxcbiAgICAgIG11bHRpTGluZVN0cmluZ3MgPSBwYXJzZXJDb25maWcubXVsdGlMaW5lU3RyaW5ncyxcbiAgICAgIGhvb2tzID0gcGFyc2VyQ29uZmlnLmhvb2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogS2V5d29yZHMgZnJvbSBJRUVFIDE4MDAtMjAxMlxuICAgKi9cbiAgdmFyIGtleXdvcmRzID0gd29yZHMoXG4gICAgXCJhY2NlcHRfb24gYWxpYXMgYWx3YXlzIGFsd2F5c19jb21iIGFsd2F5c19mZiBhbHdheXNfbGF0Y2ggYW5kIGFzc2VydCBhc3NpZ24gYXNzdW1lIGF1dG9tYXRpYyBiZWZvcmUgYmVnaW4gYmluZCBcIiArXG4gICAgICBcImJpbnMgYmluc29mIGJpdCBicmVhayBidWYgYnVmaWYwIGJ1ZmlmMSBieXRlIGNhc2UgY2FzZXggY2FzZXogY2VsbCBjaGFuZGxlIGNoZWNrZXIgY2xhc3MgY2xvY2tpbmcgY21vcyBjb25maWcgXCIgK1xuICAgICAgXCJjb25zdCBjb25zdHJhaW50IGNvbnRleHQgY29udGludWUgY292ZXIgY292ZXJncm91cCBjb3ZlcnBvaW50IGNyb3NzIGRlYXNzaWduIGRlZmF1bHQgZGVmcGFyYW0gZGVzaWduIGRpc2FibGUgXCIgK1xuICAgICAgXCJkaXN0IGRvIGVkZ2UgZWxzZSBlbmQgZW5kY2FzZSBlbmRjaGVja2VyIGVuZGNsYXNzIGVuZGNsb2NraW5nIGVuZGNvbmZpZyBlbmRmdW5jdGlvbiBlbmRnZW5lcmF0ZSBlbmRncm91cCBcIiArXG4gICAgICBcImVuZGludGVyZmFjZSBlbmRtb2R1bGUgZW5kcGFja2FnZSBlbmRwcmltaXRpdmUgZW5kcHJvZ3JhbSBlbmRwcm9wZXJ0eSBlbmRzcGVjaWZ5IGVuZHNlcXVlbmNlIGVuZHRhYmxlIGVuZHRhc2sgXCIgK1xuICAgICAgXCJlbnVtIGV2ZW50IGV2ZW50dWFsbHkgZXhwZWN0IGV4cG9ydCBleHRlbmRzIGV4dGVybiBmaW5hbCBmaXJzdF9tYXRjaCBmb3IgZm9yY2UgZm9yZWFjaCBmb3JldmVyIGZvcmsgZm9ya2pvaW4gXCIgK1xuICAgICAgXCJmdW5jdGlvbiBnZW5lcmF0ZSBnZW52YXIgZ2xvYmFsIGhpZ2h6MCBoaWdoejEgaWYgaWZmIGlmbm9uZSBpZ25vcmVfYmlucyBpbGxlZ2FsX2JpbnMgaW1wbGVtZW50cyBpbXBsaWVzIGltcG9ydCBcIiArXG4gICAgICBcImluY2RpciBpbmNsdWRlIGluaXRpYWwgaW5vdXQgaW5wdXQgaW5zaWRlIGluc3RhbmNlIGludCBpbnRlZ2VyIGludGVyY29ubmVjdCBpbnRlcmZhY2UgaW50ZXJzZWN0IGpvaW4gam9pbl9hbnkgXCIgK1xuICAgICAgXCJqb2luX25vbmUgbGFyZ2UgbGV0IGxpYmxpc3QgbGlicmFyeSBsb2NhbCBsb2NhbHBhcmFtIGxvZ2ljIGxvbmdpbnQgbWFjcm9tb2R1bGUgbWF0Y2hlcyBtZWRpdW0gbW9kcG9ydCBtb2R1bGUgXCIgK1xuICAgICAgXCJuYW5kIG5lZ2VkZ2UgbmV0dHlwZSBuZXcgbmV4dHRpbWUgbm1vcyBub3Igbm9zaG93Y2FuY2VsbGVkIG5vdCBub3RpZjAgbm90aWYxIG51bGwgb3Igb3V0cHV0IHBhY2thZ2UgcGFja2VkIFwiICtcbiAgICAgIFwicGFyYW1ldGVyIHBtb3MgcG9zZWRnZSBwcmltaXRpdmUgcHJpb3JpdHkgcHJvZ3JhbSBwcm9wZXJ0eSBwcm90ZWN0ZWQgcHVsbDAgcHVsbDEgcHVsbGRvd24gcHVsbHVwIFwiICtcbiAgICAgIFwicHVsc2VzdHlsZV9vbmRldGVjdCBwdWxzZXN0eWxlX29uZXZlbnQgcHVyZSByYW5kIHJhbmRjIHJhbmRjYXNlIHJhbmRzZXF1ZW5jZSByY21vcyByZWFsIHJlYWx0aW1lIHJlZiByZWcgXCIgK1xuICAgICAgXCJyZWplY3Rfb24gcmVsZWFzZSByZXBlYXQgcmVzdHJpY3QgcmV0dXJuIHJubW9zIHJwbW9zIHJ0cmFuIHJ0cmFuaWYwIHJ0cmFuaWYxIHNfYWx3YXlzIHNfZXZlbnR1YWxseSBzX25leHR0aW1lIFwiICtcbiAgICAgIFwic191bnRpbCBzX3VudGlsX3dpdGggc2NhbGFyZWQgc2VxdWVuY2Ugc2hvcnRpbnQgc2hvcnRyZWFsIHNob3djYW5jZWxsZWQgc2lnbmVkIHNtYWxsIHNvZnQgc29sdmUgc3BlY2lmeSBcIiArXG4gICAgICBcInNwZWNwYXJhbSBzdGF0aWMgc3RyaW5nIHN0cm9uZyBzdHJvbmcwIHN0cm9uZzEgc3RydWN0IHN1cGVyIHN1cHBseTAgc3VwcGx5MSBzeW5jX2FjY2VwdF9vbiBzeW5jX3JlamVjdF9vbiBcIiArXG4gICAgICBcInRhYmxlIHRhZ2dlZCB0YXNrIHRoaXMgdGhyb3VnaG91dCB0aW1lIHRpbWVwcmVjaXNpb24gdGltZXVuaXQgdHJhbiB0cmFuaWYwIHRyYW5pZjEgdHJpIHRyaTAgdHJpMSB0cmlhbmQgdHJpb3IgXCIgK1xuICAgICAgXCJ0cmlyZWcgdHlwZSB0eXBlZGVmIHVuaW9uIHVuaXF1ZSB1bmlxdWUwIHVuc2lnbmVkIHVudGlsIHVudGlsX3dpdGggdW50eXBlZCB1c2UgdXdpcmUgdmFyIHZlY3RvcmVkIHZpcnR1YWwgdm9pZCBcIiArXG4gICAgICBcIndhaXQgd2FpdF9vcmRlciB3YW5kIHdlYWsgd2VhazAgd2VhazEgd2hpbGUgd2lsZGNhcmQgd2lyZSB3aXRoIHdpdGhpbiB3b3IgeG5vciB4b3JcIik7XG5cbiAgLyoqIE9wZXJhdG9ycyBmcm9tIElFRUUgMTgwMC0yMDEyXG4gICAgICB1bmFyeV9vcGVyYXRvciA6Oj1cbiAgICAgICsgfCAtIHwgISB8IH4gfCAmIHwgfiYgfCB8IHwgfnwgfCBeIHwgfl4gfCBeflxuICAgICAgYmluYXJ5X29wZXJhdG9yIDo6PVxuICAgICAgKyB8IC0gfCAqIHwgLyB8ICUgfCA9PSB8ICE9IHwgPT09IHwgIT09IHwgPT0/IHwgIT0/IHwgJiYgfCB8fCB8ICoqXG4gICAgICB8IDwgfCA8PSB8ID4gfCA+PSB8ICYgfCB8IHwgXiB8IF5+IHwgfl4gfCA+PiB8IDw8IHwgPj4+IHwgPDw8XG4gICAgICB8IC0+IHwgPC0+XG4gICAgICBpbmNfb3JfZGVjX29wZXJhdG9yIDo6PSArKyB8IC0tXG4gICAgICB1bmFyeV9tb2R1bGVfcGF0aF9vcGVyYXRvciA6Oj1cbiAgICAgICEgfCB+IHwgJiB8IH4mIHwgfCB8IH58IHwgXiB8IH5eIHwgXn5cbiAgICAgIGJpbmFyeV9tb2R1bGVfcGF0aF9vcGVyYXRvciA6Oj1cbiAgICAgID09IHwgIT0gfCAmJiB8IHx8IHwgJiB8IHwgfCBeIHwgXn4gfCB+XlxuICAqL1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvW1xcK1xcLVxcKlxcLyF+JnxeJT0/Ol0vO1xuICB2YXIgaXNCcmFja2V0Q2hhciA9IC9bXFxbXFxde30oKV0vO1xuXG4gIHZhciB1bnNpZ25lZE51bWJlciA9IC9cXGRbMC05X10qLztcbiAgdmFyIGRlY2ltYWxMaXRlcmFsID0gL1xcZCpcXHMqJ3M/ZFxccypcXGRbMC05X10qL2k7XG4gIHZhciBiaW5hcnlMaXRlcmFsID0gL1xcZCpcXHMqJ3M/YlxccypbeHowMV1beHowMV9dKi9pO1xuICB2YXIgb2N0TGl0ZXJhbCA9IC9cXGQqXFxzKidzP29cXHMqW3h6MC03XVt4ejAtN19dKi9pO1xuICB2YXIgaGV4TGl0ZXJhbCA9IC9cXGQqXFxzKidzP2hcXHMqWzAtOWEtZnh6P11bMC05YS1meHo/X10qL2k7XG4gIHZhciByZWFsTGl0ZXJhbCA9IC8oXFxkW1xcZF9dKihcXC5cXGRbXFxkX10qKT9FLT9bXFxkX10rKXwoXFxkW1xcZF9dKlxcLlxcZFtcXGRfXSopL2k7XG5cbiAgdmFyIGNsb3NpbmdCcmFja2V0T3JXb3JkID0gL14oKFxcdyspfFspfVxcXV0pLztcbiAgdmFyIGNsb3NpbmdCcmFja2V0ID0gL1spfVxcXV0vO1xuXG4gIHZhciBjdXJQdW5jO1xuICB2YXIgY3VyS2V5d29yZDtcblxuICAvLyBCbG9jayBvcGVuaW5ncyB3aGljaCBhcmUgY2xvc2VkIGJ5IGEgbWF0Y2hpbmcga2V5d29yZCBpbiB0aGUgZm9ybSBvZiAoXCJlbmRcIiArIGtleXdvcmQpXG4gIC8vIEUuZy4gXCJ0YXNrXCIgPT4gXCJlbmR0YXNrXCJcbiAgdmFyIGJsb2NrS2V5d29yZHMgPSB3b3JkcyhcbiAgICBcImNhc2UgY2hlY2tlciBjbGFzcyBjbG9ja2luZyBjb25maWcgZnVuY3Rpb24gZ2VuZXJhdGUgaW50ZXJmYWNlIG1vZHVsZSBwYWNrYWdlIFwiICtcbiAgICAgIFwicHJpbWl0aXZlIHByb2dyYW0gcHJvcGVydHkgc3BlY2lmeSBzZXF1ZW5jZSB0YWJsZSB0YXNrXCJcbiAgKTtcblxuICAvLyBPcGVuaW5nL2Nsb3NpbmcgcGFpcnNcbiAgdmFyIG9wZW5DbG9zZSA9IHt9O1xuICBmb3IgKHZhciBrZXl3b3JkIGluIGJsb2NrS2V5d29yZHMpIHtcbiAgICBvcGVuQ2xvc2Vba2V5d29yZF0gPSBcImVuZFwiICsga2V5d29yZDtcbiAgfVxuICBvcGVuQ2xvc2VbXCJiZWdpblwiXSA9IFwiZW5kXCI7XG4gIG9wZW5DbG9zZVtcImNhc2V4XCJdID0gXCJlbmRjYXNlXCI7XG4gIG9wZW5DbG9zZVtcImNhc2V6XCJdID0gXCJlbmRjYXNlXCI7XG4gIG9wZW5DbG9zZVtcImRvXCIgICBdID0gXCJ3aGlsZVwiO1xuICBvcGVuQ2xvc2VbXCJmb3JrXCIgXSA9IFwiam9pbjtqb2luX2FueTtqb2luX25vbmVcIjtcbiAgb3BlbkNsb3NlW1wiY292ZXJncm91cFwiXSA9IFwiZW5kZ3JvdXBcIjtcblxuICBmb3IgKHZhciBpIGluIG5vSW5kZW50S2V5d29yZHMpIHtcbiAgICB2YXIga2V5d29yZCA9IG5vSW5kZW50S2V5d29yZHNbaV07XG4gICAgaWYgKG9wZW5DbG9zZVtrZXl3b3JkXSkge1xuICAgICAgb3BlbkNsb3NlW2tleXdvcmRdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8vIEtleXdvcmRzIHdoaWNoIG9wZW4gc3RhdGVtZW50cyB0aGF0IGFyZSBlbmRlZCB3aXRoIGEgc2VtaS1jb2xvblxuICB2YXIgc3RhdGVtZW50S2V5d29yZHMgPSB3b3JkcyhcImFsd2F5cyBhbHdheXNfY29tYiBhbHdheXNfZmYgYWx3YXlzX2xhdGNoIGFzc2VydCBhc3NpZ24gYXNzdW1lIGVsc2UgZXhwb3J0IGZvciBmb3JlYWNoIGZvcmV2ZXIgaWYgaW1wb3J0IGluaXRpYWwgcmVwZWF0IHdoaWxlXCIpO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKSwgc3R5bGU7XG4gICAgaWYgKGhvb2tzW2NoXSAmJiAoc3R5bGUgPSBob29rc1tjaF0oc3RyZWFtLCBzdGF0ZSkpICE9IGZhbHNlKSByZXR1cm4gc3R5bGU7XG4gICAgaWYgKGhvb2tzLnRva2VuQmFzZSAmJiAoc3R5bGUgPSBob29rcy50b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkpICE9IGZhbHNlKVxuICAgICAgcmV0dXJuIHN0eWxlO1xuXG4gICAgaWYgKC9bLDs6XFwuXS8udGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0JyYWNrZXRDaGFyLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICB9XG4gICAgLy8gTWFjcm9zICh0aWNrLWRlZmluZXMpXG4gICAgaWYgKGNoID09ICdgJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pKSB7XG4gICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFN5c3RlbSBjYWxsc1xuICAgIGlmIChjaCA9PSAnJCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKSkge1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGltZSBsaXRlcmFsc1xuICAgIGlmIChjaCA9PSAnIycpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRfLl0vKTtcbiAgICAgIHJldHVybiBcImRlZlwiO1xuICAgIH1cbiAgICAvLyBTdHJpbmdzXG4gICAgaWYgKGNoID09ICdcIicpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gQ29tbWVudHNcbiAgICBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgIH1cblxuICAgIC8vIE51bWVyaWMgbGl0ZXJhbHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHJlYWxMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goZGVjaW1hbExpdGVyYWwpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChiaW5hcnlMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2gob2N0TGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKGhleExpdGVyYWwpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaCh1bnNpZ25lZE51bWJlcikgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJlYWxMaXRlcmFsKSkge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuXG4gICAgLy8gT3BlcmF0b3JzXG4gICAgaWYgKHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcikpIHtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9XG5cbiAgICAvLyBLZXl3b3JkcyAvIHBsYWluIHZhcmlhYmxlc1xuICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pKSB7XG4gICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIGlmIChrZXl3b3Jkc1tjdXJdKSB7XG4gICAgICAgIGlmIChvcGVuQ2xvc2VbY3VyXSkge1xuICAgICAgICAgIGN1clB1bmMgPSBcIm5ld2Jsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlbWVudEtleXdvcmRzW2N1cl0pIHtcbiAgICAgICAgICBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICBjdXJLZXl3b3JkID0gY3VyO1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cblxuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgbXVsdGlMaW5lU3RyaW5ncykpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgfVxuICBmdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlKSB7XG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudGVkO1xuICAgIHZhciBjID0gbmV3IENvbnRleHQoaW5kZW50LCBjb2wsIHR5cGUsIG51bGwsIHN0YXRlLmNvbnRleHQpO1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gYztcbiAgfVxuICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgaWYgKHQgPT0gXCIpXCIgfHwgdCA9PSBcIl1cIiB8fCB0ID09IFwifVwiKSB7XG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDbG9zaW5nKHRleHQsIGNvbnRleHRDbG9zaW5nKSB7XG4gICAgaWYgKHRleHQgPT0gY29udGV4dENsb3NpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb250ZXh0Q2xvc2luZyBtYXkgYmUgbXVsdGlwbGUga2V5d29yZHMgc2VwYXJhdGVkIGJ5IDtcbiAgICAgIHZhciBjbG9zaW5nS2V5d29yZHMgPSBjb250ZXh0Q2xvc2luZy5zcGxpdChcIjtcIik7XG4gICAgICBmb3IgKHZhciBpIGluIGNsb3NpbmdLZXl3b3Jkcykge1xuICAgICAgICBpZiAodGV4dCA9PSBjbG9zaW5nS2V5d29yZHNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkRWxlY3RyaWNJbnB1dFJlZ0V4KCkge1xuICAgIC8vIFJlaW5kZW50YXRpb24gc2hvdWxkIG9jY3VyIG9uIGFueSBicmFja2V0IGNoYXI6IHt9KClbXVxuICAgIC8vIG9yIG9uIGEgbWF0Y2ggb2YgYW55IG9mIHRoZSBibG9jayBjbG9zaW5nIGtleXdvcmRzLCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgYSBsaW5lXG4gICAgdmFyIGFsbENsb3NpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvcGVuQ2xvc2UpIHtcbiAgICAgIGlmIChvcGVuQ2xvc2VbaV0pIHtcbiAgICAgICAgdmFyIGNsb3NpbmdzID0gb3BlbkNsb3NlW2ldLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBjbG9zaW5ncykge1xuICAgICAgICAgIGFsbENsb3NpbmdzLnB1c2goY2xvc2luZ3Nbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJbe30oKVxcXFxbXFxcXF1dfChcIiArIGFsbENsb3NpbmdzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcbiAgICByZXR1cm4gcmU7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcInZlcmlsb2dcIixcblxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGluZGVudFVuaXQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KC1pbmRlbnRVbml0LCAwLCBcInRvcFwiLCBmYWxzZSksXG4gICAgICAgIGluZGVudGVkOiAwLFxuICAgICAgICBzdGFydE9mTGluZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChob29rcy5zdGFydFN0YXRlKSBob29rcy5zdGFydFN0YXRlKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaG9va3MudG9rZW4pIHtcbiAgICAgICAgLy8gQ2FsbCBob29rLCB3aXRoIGFuIG9wdGlvbmFsIHJldHVybiB2YWx1ZSBvZiBhIHN0eWxlIHRvIG92ZXJyaWRlIHZlcmlsb2cgc3R5bGluZy5cbiAgICAgICAgdmFyIHN0eWxlID0gaG9va3MudG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgY3VyUHVuYyA9IG51bGw7XG4gICAgICBjdXJLZXl3b3JkID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiIHx8IHN0eWxlID09IFwidmFyaWFibGVcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgICBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkge1xuICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoKGN1clB1bmMgPT0gXCI7XCIgJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgfHxcbiAgICAgICAgICAgICAgICAgKGN0eC50eXBlICYmIGlzQ2xvc2luZyhjdXJLZXl3b3JkLCBjdHgudHlwZSkpKSB7XG4gICAgICAgIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB3aGlsZSAoY3R4ICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwie1wiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIl1cIik7XG4gICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCIpXCIpO1xuICAgICAgfSBlbHNlIGlmIChjdHggJiYgY3R4LnR5cGUgPT0gXCJlbmRjYXNlXCIgJiYgY3VyUHVuYyA9PSBcIjpcIikge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwic3RhdGVtZW50XCIpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwibmV3YmxvY2tcIikge1xuICAgICAgICBpZiAoY3VyS2V5d29yZCA9PSBcImZ1bmN0aW9uXCIgJiYgY3R4ICYmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiIHx8IGN0eC50eXBlID09IFwiZW5kZ3JvdXBcIikpIHtcbiAgICAgICAgICAvLyBUaGUgJ2Z1bmN0aW9uJyBrZXl3b3JkIGNhbiBhcHBlYXIgaW4gc29tZSBvdGhlciBjb250ZXh0cyB3aGVyZSBpdCBhY3R1YWxseSBkb2VzIG5vdFxuICAgICAgICAgIC8vIGluZGljYXRlIGEgZnVuY3Rpb24gKGltcG9ydC9leHBvcnQgRFBJIGFuZCBjb3Zlcmdyb3VwIGRlZmluaXRpb25zKS5cbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGluIHRoaXMgY2FzZVxuICAgICAgICB9IGVsc2UgaWYgKGN1cktleXdvcmQgPT0gXCJ0YXNrXCIgJiYgY3R4ICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAvLyBTYW1lIHRoaW5nIGZvciB0YXNrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsb3NlID0gb3BlbkNsb3NlW2N1cktleXdvcmRdO1xuICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIGNsb3NlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlICYmIHN0YXRlLnRva2VuaXplICE9IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgaWYgKGhvb2tzLmluZGVudCkge1xuICAgICAgICB2YXIgZnJvbUhvb2sgPSBob29rcy5pbmRlbnQoc3RhdGUpO1xuICAgICAgICBpZiAoZnJvbUhvb2sgPj0gMCkgcmV0dXJuIGZyb21Ib29rO1xuICAgICAgfVxuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQsIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBjdHggPSBjdHgucHJldjtcbiAgICAgIHZhciBjbG9zaW5nID0gZmFsc2U7XG4gICAgICB2YXIgcG9zc2libGVDbG9zaW5nID0gdGV4dEFmdGVyLm1hdGNoKGNsb3NpbmdCcmFja2V0T3JXb3JkKTtcbiAgICAgIGlmIChwb3NzaWJsZUNsb3NpbmcpXG4gICAgICAgIGNsb3NpbmcgPSBpc0Nsb3NpbmcocG9zc2libGVDbG9zaW5nWzBdLCBjdHgudHlwZSk7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChmaXJzdENoYXIgPT0gXCJ7XCIgPyAwIDogc3RhdGVtZW50SW5kZW50VW5pdCB8fCBjeC51bml0KTtcbiAgICAgIGVsc2UgaWYgKGNsb3NpbmdCcmFja2V0LnRlc3QoY3R4LnR5cGUpICYmIGN0eC5hbGlnbiAmJiAhZG9udEFsaWduQ2FsbHMpIHJldHVybiBjdHguY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIGlmIChjdHgudHlwZSA9PSBcIilcIiAmJiAhY2xvc2luZykgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChzdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGN4LnVuaXQpO1xuICAgICAgZWxzZSByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogY3gudW5pdCk7XG4gICAgfSxcblxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgaW5kZW50T25JbnB1dDogYnVpbGRFbGVjdHJpY0lucHV0UmVnRXgoKSxcbiAgICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWxvZyA9IG1rVmVyaWxvZyh7fSlcblxuLy8gVEwtVmVyaWxvZyBtb2RlLlxuLy8gU2VlIHRsLXgub3JnIGZvciBsYW5ndWFnZSBzcGVjLlxuLy8gU2VlIHRoZSBtb2RlIGluIGFjdGlvbiBhdCBtYWtlcmNoaXAuY29tLlxuLy8gQ29udGFjdDogc3RldmUuaG9vdmVyQHJlZHdvb2RlZGEuY29tXG5cbi8vIFRMViBJZGVudGlmaWVyIHByZWZpeGVzLlxuLy8gTm90ZSB0aGF0IHNpZ24gaXMgbm90IHRyZWF0ZWQgc2VwYXJhdGVseSwgc28gXCIrLy1cIiB2ZXJzaW9ucyBvZiBudW1lcmljIGlkZW50aWZpZXJzXG4vLyBhcmUgaW5jbHVkZWQuXG52YXIgdGx2SWRlbnRpZmllclN0eWxlID0ge1xuICBcInxcIjogXCJsaW5rXCIsXG4gIFwiPlwiOiBcInByb3BlcnR5XCIsICAvLyBTaG91bGQgY29uZGl0aW9uIHRoaXMgb2ZmIGZvciA+IFRMViAxYy5cbiAgXCIkXCI6IFwidmFyaWFibGVcIixcbiAgXCIkJFwiOiBcInZhcmlhYmxlXCIsXG4gIFwiPyRcIjogXCJxdWFsaWZpZXJcIixcbiAgXCI/KlwiOiBcInF1YWxpZmllclwiLFxuICBcIi1cIjogXCJjb250ZW50U2VwYXJhdG9yXCIsXG4gIFwiL1wiOiBcInByb3BlcnR5XCIsXG4gIFwiLy1cIjogXCJwcm9wZXJ0eVwiLFxuICBcIkBcIjogXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiLFxuICBcIkAtXCI6IFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIixcbiAgXCJAKytcIjogXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiLFxuICBcIkArPVwiOiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCIsXG4gIFwiQCs9LVwiOiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCIsXG4gIFwiQC0tXCI6IFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIixcbiAgXCJALT1cIjogXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiLFxuICBcIiUrXCI6IFwidGFnXCIsXG4gIFwiJS1cIjogXCJ0YWdcIixcbiAgXCIlXCI6IFwidGFnXCIsXG4gIFwiPj5cIjogXCJ0YWdcIixcbiAgXCI8PFwiOiBcInRhZ1wiLFxuICBcIjw+XCI6IFwidGFnXCIsXG4gIFwiI1wiOiBcInRhZ1wiLCAgLy8gTmVlZCB0byBjaG9vc2UgYSBzdHlsZSBmb3IgdGhpcy5cbiAgXCJeXCI6IFwiYXR0cmlidXRlXCIsXG4gIFwiXl5cIjogXCJhdHRyaWJ1dGVcIixcbiAgXCJeIVwiOiBcImF0dHJpYnV0ZVwiLFxuICBcIipcIjogXCJ2YXJpYWJsZVwiLFxuICBcIioqXCI6IFwidmFyaWFibGVcIixcbiAgXCJcXFxcXCI6IFwia2V5d29yZFwiLFxuICBcIlxcXCJcIjogXCJjb21tZW50XCJcbn07XG5cbi8vIExpbmVzIHN0YXJ0aW5nIHdpdGggdGhlc2UgY2hhcmFjdGVycyBkZWZpbmUgc2NvcGUgKHJlc3VsdCBpbiBpbmRlbnRhdGlvbikuXG52YXIgdGx2U2NvcGVQcmVmaXhDaGFycyA9IHtcbiAgXCIvXCI6IFwiYmVoLWhpZXJcIixcbiAgXCI+XCI6IFwiYmVoLWhpZXJcIixcbiAgXCItXCI6IFwicGh5cy1oaWVyXCIsXG4gIFwifFwiOiBcInBpcGVcIixcbiAgXCI/XCI6IFwid2hlblwiLFxuICBcIkBcIjogXCJzdGFnZVwiLFxuICBcIlxcXFxcIjogXCJrZXl3b3JkXCJcbn07XG52YXIgdGx2SW5kZW50VW5pdCA9IDM7XG52YXIgdGx2VHJhY2tTdGF0ZW1lbnRzID0gZmFsc2U7XG52YXIgdGx2SWRlbnRNYXRjaCA9IC9eKFt+IUAjXFwkJVxcXiZcXCotXFwrPVxcP1xcL1xcXFxcXHwnXCI8Pl0rKShbXFxkXFx3X10qKS87ICAvLyBNYXRjaGVzIGFuIGlkZW50aWZpZXIuXG4vLyBOb3RlIHRoYXQgJzonIGlzIGV4Y2x1ZGVkLCBiZWNhdXNlIG9mIGl0J3MgdXNlIGluIFs6XS5cbnZhciB0bHZMaW5lSW5kZW50YXRpb25NYXRjaCA9IC9eWyEgXSAqLztcbnZhciB0bHZDb21tZW50TWF0Y2ggPSAvXlxcL1tcXC9cXCpdLztcblxuZXhwb3J0IGNvbnN0IHRsdiA9IG1rVmVyaWxvZyh7XG4gIGhvb2tzOiB7XG4gICAgZWxlY3RyaWNJbnB1dDogZmFsc2UsXG5cbiAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGZvciB2ZXJpbG9nIHRva2VuaXppbmcsIG9yIHN0eWxlIGZvciBUTFYgdG9rZW4gKG51bGwgbm90IHVzZWQpLlxuICAgIC8vIFN0YW5kYXJkIENNIHN0eWxlcyBhcmUgdXNlZCBmb3IgbW9zdCBmb3JtYXR0aW5nLCBidXQgc29tZSBUTC1WZXJpbG9nLXNwZWNpZmljIGhpZ2hsaWdodGluZ1xuICAgIC8vIGNhbiBiZSBlbmFibGVkIHdpdGggdGhlIGRlZmluaXRpb24gb2YgY20tdGx2LSogc3R5bGVzLCBpbmNsdWRpbmcgaGlnaGxpZ2h0aW5nIGZvcjpcbiAgICAvLyAgIC0gTTQgdG9rZW5zXG4gICAgLy8gICAtIFRMViBzY29wZSBpbmRlbnRhdGlvblxuICAgIC8vICAgLSBTdGF0ZW1lbnQgZGVsaW1pdGF0aW9uIChlbmFibGVkIGJ5IHRsdlRyYWNrU3RhdGVtZW50cylcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHN0eWxlID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hdGNoOyAgLy8gUmV0dXJuIHZhbHVlIG9mIHBhdHRlcm4gbWF0Y2hlcy5cblxuICAgICAgLy8gU2V0IGhpZ2hsaWdodGluZyBtb2RlIGJhc2VkIG9uIGNvZGUgcmVnaW9uIChUTFYgb3IgU1YpLlxuICAgICAgaWYgKHN0cmVhbS5zb2woKSAmJiAhIHN0YXRlLnRsdkluQmxvY2tDb21tZW50KSB7XG4gICAgICAgIC8vIFByb2Nlc3MgcmVnaW9uLlxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnXFxcXCcpIHtcbiAgICAgICAgICBzdHlsZSA9IFwiZGVmXCI7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIGlmIChzdHJlYW0uc3RyaW5nLm1hdGNoKC9cXFxcU1YvKSkge1xuICAgICAgICAgICAgc3RhdGUudGx2Q29kZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXFxcXFRMVi8pKXtcbiAgICAgICAgICAgIHN0YXRlLnRsdkNvZGVBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb3JyZWN0IGluZGVudGF0aW9uIGluIHRoZSBmYWNlIG9mIGEgbGluZSBwcmVmaXggY2hhci5cbiAgICAgICAgaWYgKHN0YXRlLnRsdkNvZGVBY3RpdmUgJiYgc3RyZWFtLnBvcyA9PSAwICYmXG4gICAgICAgICAgICAoc3RhdGUuaW5kZW50ZWQgPT0gMCkgJiYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKHRsdkxpbmVJbmRlbnRhdGlvbk1hdGNoLCBmYWxzZSkpKSB7XG4gICAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIGluZGVudGF0aW9uIHN0YXRlOlxuICAgICAgICAvLyAgIG8gQXV0byBpbmRlbnRhdGlvbiBvbiBuZXh0IGxpbmVcbiAgICAgICAgLy8gICBvIEluZGVudGF0aW9uIHNjb3BlIHN0eWxlc1xuICAgICAgICB2YXIgaW5kZW50ZWQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgICAgdmFyIGRlcHRoID0gaW5kZW50ZWQgLyB0bHZJbmRlbnRVbml0O1xuICAgICAgICBpZiAoZGVwdGggPD0gc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBub3QgZGVlcGVyIHRoYW4gY3VycmVudCBzY29wZVxuXG4gICAgICAgICAgdmFyIGJsYW5rbGluZSA9IHN0cmVhbS5zdHJpbmcubGVuZ3RoID09IGluZGVudGVkO1xuICAgICAgICAgIHZhciBjaFBvcyA9IGRlcHRoICogdGx2SW5kZW50VW5pdDtcbiAgICAgICAgICBpZiAoY2hQb3MgPCBzdHJlYW0uc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJvZHlTdHJpbmcgPSBzdHJlYW0uc3RyaW5nLnNsaWNlKGNoUG9zKTtcbiAgICAgICAgICAgIHZhciBjaCA9IGJvZHlTdHJpbmdbMF07XG4gICAgICAgICAgICBpZiAodGx2U2NvcGVQcmVmaXhDaGFyc1tjaF0gJiYgKChtYXRjaCA9IGJvZHlTdHJpbmcubWF0Y2godGx2SWRlbnRNYXRjaCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRsdklkZW50aWZpZXJTdHlsZVttYXRjaFsxXV0pKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgbGluZSBiZWdpbnMgc2NvcGUuXG4gICAgICAgICAgICAgIC8vIE5leHQgbGluZSBnZXRzIGluZGVudGVkIG9uZSBsZXZlbC5cbiAgICAgICAgICAgICAgaW5kZW50ZWQgKz0gdGx2SW5kZW50VW5pdDtcbiAgICAgICAgICAgICAgLy8gU3R5bGUgdGhlIG5leHQgbGV2ZWwgb2YgaW5kZW50YXRpb24gKGV4Y2VwdCBub24tcmVnaW9uIGtleXdvcmQgaWRlbnRpZmllcnMsXG4gICAgICAgICAgICAgIC8vICAgd2hpY2ggYXJlIHN0YXRlbWVudHMgdGhlbXNlbHZlcylcbiAgICAgICAgICAgICAgaWYgKCEoY2ggPT0gXCJcXFxcXCIgJiYgY2hQb3MgPiAwKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGVbZGVwdGhdID0gdGx2U2NvcGVQcmVmaXhDaGFyc1tjaF07XG4gICAgICAgICAgICAgICAgaWYgKHRsdlRyYWNrU3RhdGVtZW50cykge3N0YXRlLnN0YXRlbWVudENvbW1lbnQgPSBmYWxzZTt9XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDbGVhciBvdXQgZGVlcGVyIGluZGVudGF0aW9uIGxldmVscyB1bmxlc3MgbGluZSBpcyBibGFuay5cbiAgICAgICAgICBpZiAoIWJsYW5rbGluZSkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUubGVuZ3RoID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5leHQgbGV2ZWwgb2YgaW5kZW50YXRpb24uXG4gICAgICAgIHN0YXRlLnRsdk5leHRJbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLnRsdkNvZGVBY3RpdmUpIHtcbiAgICAgICAgLy8gSGlnaGxpZ2h0IGFzIFRMVi5cblxuICAgICAgICB2YXIgYmVnaW5TdGF0ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRsdlRyYWNrU3RhdGVtZW50cykge1xuICAgICAgICAgIC8vIFRoaXMgc3RhcnRzIGEgc3RhdGVtZW50IGlmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgc2NvcGUgbGV2ZWxcbiAgICAgICAgICAvLyBhbmQgd2UncmUgbm90IHdpdGhpbiBhIHN0YXRlbWVudCBsZWFkaW5nIGNvbW1lbnQuXG4gICAgICAgICAgYmVnaW5TdGF0ZW1lbnQgPVxuICAgICAgICAgICAgKHN0cmVhbS5wZWVrKCkgIT0gXCIgXCIpICYmICAgLy8gbm90IGEgc3BhY2VcbiAgICAgICAgICAgIChzdHlsZSA9PT0gdW5kZWZpbmVkKSAmJiAgICAvLyBub3QgYSByZWdpb24gaWRlbnRpZmllclxuICAgICAgICAgICAgIXN0YXRlLnRsdkluQmxvY2tDb21tZW50ICYmIC8vIG5vdCBpbiBibG9jayBjb21tZW50XG4gICAgICAgICAgICAvLyFzdHJlYW0ubWF0Y2godGx2Q29tbWVudE1hdGNoLCBmYWxzZSkgJiYgLy8gbm90IGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAoc3RyZWFtLmNvbHVtbigpID09IHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUubGVuZ3RoICogdGx2SW5kZW50VW5pdCk7ICAvLyBhdCBzY29wZSBsZXZlbFxuICAgICAgICAgIGlmIChiZWdpblN0YXRlbWVudCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXRlbWVudENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgLy8gc3RhdGVtZW50IGFscmVhZHkgc3RhcnRlZCBieSBjb21tZW50XG4gICAgICAgICAgICAgIGJlZ2luU3RhdGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5zdGF0ZW1lbnRDb21tZW50ID1cbiAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKHRsdkNvbW1lbnRNYXRjaCwgZmFsc2UpOyAvLyBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnRsdkluQmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgLy8gSW4gYSBibG9jayBjb21tZW50LlxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14uKj9cXCpcXC8vKSkge1xuICAgICAgICAgICAgLy8gRXhpdCBibG9jayBjb21tZW50LlxuICAgICAgICAgICAgc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0bHZUcmFja1N0YXRlbWVudHMgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAvLyBBbnl0aGluZyBhZnRlciBjb21tZW50IGlzIGFzc3VtZWQgdG8gYmUgcmVhbCBzdGF0ZW1lbnQgY29udGVudC5cbiAgICAgICAgICAgICAgc3RhdGUuc3RhdGVtZW50Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlID0gXCJjb21tZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gc3RyZWFtLm1hdGNoKHRsdkNvbW1lbnRNYXRjaCkpICYmICFzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCkge1xuICAgICAgICAgIC8vIFN0YXJ0IGNvbW1lbnQuXG4gICAgICAgICAgaWYgKG1hdGNoWzBdID09IFwiLy9cIikge1xuICAgICAgICAgICAgLy8gTGluZSBjb21tZW50LlxuICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCbG9jayBjb21tZW50LlxuICAgICAgICAgICAgc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZSA9IFwiY29tbWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKHRsdklkZW50TWF0Y2gpKSB7XG4gICAgICAgICAgLy8gbG9va3MgbGlrZSBhbiBpZGVudGlmaWVyIChvciBpZGVudGlmaWVyIHByZWZpeClcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV07XG4gICAgICAgICAgdmFyIG1uZW1vbmljID0gbWF0Y2hbMl07XG4gICAgICAgICAgaWYgKC8vIGlzIGlkZW50aWZpZXIgcHJlZml4XG4gICAgICAgICAgICB0bHZJZGVudGlmaWVyU3R5bGUuaGFzT3duUHJvcGVydHkocHJlZml4KSAmJlxuICAgICAgICAgICAgICAvLyBoYXMgbW5lbW9uaWMgb3Igd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAobWF5YmUgaXQgaGFzbid0IGJlZW4gdHlwZWQgeWV0KVxuICAgICAgICAgICAgKG1uZW1vbmljLmxlbmd0aCA+IDAgfHwgc3RyZWFtLmVvbCgpKSkge1xuICAgICAgICAgICAgc3R5bGUgPSB0bHZJZGVudGlmaWVyU3R5bGVbcHJlZml4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSnVzdCBzd2FsbG93IG9uZSBjaGFyYWN0ZXIgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5hYmxlcyBzdWJzZXF1ZW50IGlkZW50aWZpZXIgbWF0Y2ggd2l0aCBwcmVjZWRpbmcgc3ltYm9sIGNoYXJhY3Rlciwgd2hpY2hcbiAgICAgICAgICAgIC8vICAgaXMgbGVnYWwgd2l0aGluIGEgc3RhdGVtZW50LiAgKEVnLCAhJHJlc2V0KS4gIEl0IGFsc28gZW5hYmxlcyBkZXRlY3Rpb24gb2ZcbiAgICAgICAgICAgIC8vICAgY29tbWVudCBzdGFydCB3aXRoIHByZWNlZGluZyBzeW1ib2xzLlxuICAgICAgICAgICAgc3RyZWFtLmJhY2tVcChzdHJlYW0uY3VycmVudCgpLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15cXHQrLykpIHtcbiAgICAgICAgICAvLyBIaWdobGlnaHQgdGFicywgd2hpY2ggYXJlIGlsbGVnYWwuXG4gICAgICAgICAgc3R5bGUgPSBcImludmFsaWRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bXFxbXFxde31cXChcXCk7XFw6XSsvKSkge1xuICAgICAgICAgIC8vIFs6XSwgKCksIHt9LCA7LlxuICAgICAgICAgIHN0eWxlID0gXCJtZXRhXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL15bbU1dNChbXFwrX10pP1tcXHdcXGRfXSovKSkge1xuICAgICAgICAgIC8vIG00IHByZSBwcm9jXG4gICAgICAgICAgc3R5bGUgPSAobWF0Y2hbMV0gPT0gXCIrXCIpID8gXCJrZXl3b3JkLnNwZWNpYWxcIiA6IFwia2V5d29yZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiArLykpe1xuICAgICAgICAgIC8vIFNraXAgb3ZlciBzcGFjZXMuXG4gICAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgLy8gVHJhaWxpbmcgc3BhY2VzLlxuICAgICAgICAgICAgc3R5bGUgPSBcImVycm9yXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXltcXHdcXGRfXSsvKSkge1xuICAgICAgICAgIC8vIGFscGhhLW51bWVyaWMgdG9rZW4uXG4gICAgICAgICAgc3R5bGUgPSBcIm51bWJlclwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVhdCB0aGUgbmV4dCBjaGFyIHcvIG5vIGZvcm1hdHRpbmcuXG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlttTV00KFtcXHdcXGRfXSopLykpIHtcbiAgICAgICAgICAvLyBtNCBwcmUgcHJvY1xuICAgICAgICAgIHN0eWxlID0gXCJrZXl3b3JkXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIChzdGF0ZS50bHZDb2RlQWN0aXZlID09IHRydWUpID8gc3RhdGUudGx2TmV4dEluZGVudCA6IC0xO1xuICAgIH0sXG5cbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZSA9IFtdOyAgLy8gU3R5bGVzIHRvIHVzZSBmb3IgZWFjaCBsZXZlbCBvZiBpbmRlbnRhdGlvbi5cbiAgICAgIHN0YXRlLnRsdkNvZGVBY3RpdmUgPSB0cnVlOyAgLy8gVHJ1ZSB3aGVuIHdlJ3JlIGluIGEgVExWIHJlZ2lvbiAoYW5kIGF0IGJlZ2lubmluZyBvZiBmaWxlKS5cbiAgICAgIHN0YXRlLnRsdk5leHRJbmRlbnQgPSAtMTsgICAgLy8gVGhlIG51bWJlciBvZiBzcGFjZXMgdG8gYXV0b2luZGVudCB0aGUgbmV4dCBsaW5lIGlmIHRsdkNvZGVBY3RpdmUuXG4gICAgICBzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCA9IGZhbHNlOyAgLy8gVHJ1ZSBpbnNpZGUgLyoqLyBjb21tZW50LlxuICAgICAgaWYgKHRsdlRyYWNrU3RhdGVtZW50cykge1xuICAgICAgICBzdGF0ZS5zdGF0ZW1lbnRDb21tZW50ID0gZmFsc2U7ICAvLyBUcnVlIGluc2lkZSBhIHN0YXRlbWVudCdzIGhlYWRlciBjb21tZW50LlxuICAgICAgfVxuICAgIH1cblxuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/verilog.js\n"));

/***/ })

}]);