"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_xquery_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/xquery.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/xquery.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xQuery: function() { return /* binding */ xQuery; }\n/* harmony export */ });\n// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return chain(stream, state, tokenString(ch));\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n\n    if(isInString(state) && stream.current() == quote) {\n      popStateStack(state);\n      if(f) state.tokenize = f;\n      return \"string\";\n    }\n\n    pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n    // if we're in a string and in an XML block, allow an embedded code block\n    if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n      state.tokenize = tokenBase;\n      return \"string\";\n    }\n\n\n    while (ch = stream.next()) {\n      if (ch ==  quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        break;\n      }\n      else {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n      }\n    }\n\n    return \"string\";\n  };\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return chain(stream, state, tokenString(ch, tokenAttribute));\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nconst xQuery = {\n  name: \"xquery\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS94cXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxrQ0FBa0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxPQUFPOztBQUU3QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLE9BQU87O0FBRTdDLCtEQUErRDtBQUMvRDtBQUNBLG1DQUFtQyxPQUFPLE9BQU87O0FBRWpELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sT0FBTzs7QUFFdkQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHVCQUF1Qjs7QUFFakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qiw4REFBOEQ7O0FBRTFGO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDRDQUE0Qzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUveHF1ZXJ5LmpzPzJhNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIGtleXdvcmRzIG9iamVjdCBpcyBzZXQgdG8gdGhlIHJlc3VsdCBvZiB0aGlzIHNlbGYgZXhlY3V0aW5nXG4vLyBmdW5jdGlvbi4gRWFjaCBrZXl3b3JkIGlzIGEgcHJvcGVydHkgb2YgdGhlIGtleXdvcmRzIG9iamVjdCB3aG9zZVxuLy8gdmFsdWUgaXMge3R5cGU6IGF0eXBlLCBzdHlsZTogYXN0eWxlfVxudmFyIGtleXdvcmRzID0gZnVuY3Rpb24oKXtcbiAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb25zIHVzZWQgdG8gYnVpbGQga2V5d29yZHMgb2JqZWN0XG4gIGZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxuICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpXG4gICwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICAsIHB1bmN0dWF0aW9uID0ge3R5cGU6IFwicHVuY3R1YXRpb25cIiwgc3R5bGU6IG51bGx9XG4gICwgcXVhbGlmaWVyID0ge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9O1xuXG4gIC8vIGt3T2JqIGlzIHdoYXQgaXMgcmV0dXJuIGZyb20gdGhpcyBmdW5jdGlvbiBhdCB0aGUgZW5kXG4gIHZhciBrd09iaiA9IHtcbiAgICAnLCc6IHB1bmN0dWF0aW9uXG4gIH07XG5cbiAgLy8gYSBsaXN0IG9mICdiYXNpYycga2V5d29yZHMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gIC8vIHt0eXBlOiBiYXNpY1tpXSwgc3R5bGU6IFwia2V5d29yZFwifSBlLmcuICdhZnRlcicgLS0+IHt0eXBlOiBcImFmdGVyXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgdmFyIGJhc2ljID0gWydhZnRlcicsICdhbGwnLCAnYWxsb3dpbmcnLCAnYW5jZXN0b3InLCAnYW5jZXN0b3Itb3Itc2VsZicsICdhbnknLCAnYXJyYXknLCAnYXMnLFxuICAgICAgICAgICAgICAgJ2FzY2VuZGluZycsICdhdCcsICdhdHRyaWJ1dGUnLCAnYmFzZS11cmknLCAnYmVmb3JlJywgJ2JvdW5kYXJ5LXNwYWNlJywgJ2J5JywgJ2Nhc2UnLCAnY2FzdCcsXG4gICAgICAgICAgICAgICAnY2FzdGFibGUnLCAnY2F0Y2gnLCAnY2hpbGQnLCAnY29sbGF0aW9uJywgJ2NvbW1lbnQnLCAnY29uc3RydWN0aW9uJywgJ2NvbnRhaW5zJywgJ2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgJ2NvbnRleHQnLCAnY29weScsICdjb3B5LW5hbWVzcGFjZXMnLCAnY291bnQnLCAnZGVjaW1hbC1mb3JtYXQnLCAnZGVjbGFyZScsICdkZWZhdWx0JywgJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAnZGVzY2VuZGFudCcsICdkZXNjZW5kYW50LW9yLXNlbGYnLCAnZGVzY2VuZGluZycsICdkaWFjcml0aWNzJywgJ2RpZmZlcmVudCcsICdkaXN0YW5jZScsXG4gICAgICAgICAgICAgICAnZG9jdW1lbnQnLCAnZG9jdW1lbnQtbm9kZScsICdlbGVtZW50JywgJ2Vsc2UnLCAnZW1wdHknLCAnZW1wdHktc2VxdWVuY2UnLCAnZW5jb2RpbmcnLCAnZW5kJyxcbiAgICAgICAgICAgICAgICdlbnRpcmUnLCAnZXZlcnknLCAnZXhhY3RseScsICdleGNlcHQnLCAnZXh0ZXJuYWwnLCAnZmlyc3QnLCAnZm9sbG93aW5nJywgJ2ZvbGxvd2luZy1zaWJsaW5nJyxcbiAgICAgICAgICAgICAgICdmb3InLCAnZnJvbScsICdmdGFuZCcsICdmdG5vdCcsICdmdC1vcHRpb24nLCAnZnRvcicsICdmdW5jdGlvbicsICdmdXp6eScsICdncmVhdGVzdCcsICdncm91cCcsXG4gICAgICAgICAgICAgICAnaWYnLCAnaW1wb3J0JywgJ2luJywgJ2luaGVyaXQnLCAnaW5zZW5zaXRpdmUnLCAnaW5zZXJ0JywgJ2luc3RhbmNlJywgJ2ludGVyc2VjdCcsICdpbnRvJyxcbiAgICAgICAgICAgICAgICdpbnZva2UnLCAnaXMnLCAnaXRlbScsICdsYW5ndWFnZScsICdsYXN0JywgJ2xheCcsICdsZWFzdCcsICdsZXQnLCAnbGV2ZWxzJywgJ2xvd2VyY2FzZScsICdtYXAnLFxuICAgICAgICAgICAgICAgJ21vZGlmeScsICdtb2R1bGUnLCAnbW9zdCcsICduYW1lc3BhY2UnLCAnbmV4dCcsICdubycsICdub2RlJywgJ25vZGVzJywgJ25vLWluaGVyaXQnLFxuICAgICAgICAgICAgICAgJ25vLXByZXNlcnZlJywgJ25vdCcsICdvY2N1cnMnLCAnb2YnLCAnb25seScsICdvcHRpb24nLCAnb3JkZXInLCAnb3JkZXJlZCcsICdvcmRlcmluZycsXG4gICAgICAgICAgICAgICAncGFyYWdyYXBoJywgJ3BhcmFncmFwaHMnLCAncGFyZW50JywgJ3BocmFzZScsICdwcmVjZWRpbmcnLCAncHJlY2VkaW5nLXNpYmxpbmcnLCAncHJlc2VydmUnLFxuICAgICAgICAgICAgICAgJ3ByZXZpb3VzJywgJ3Byb2Nlc3NpbmctaW5zdHJ1Y3Rpb24nLCAncmVsYXRpb25zaGlwJywgJ3JlbmFtZScsICdyZXBsYWNlJywgJ3JldHVybicsXG4gICAgICAgICAgICAgICAncmV2YWxpZGF0aW9uJywgJ3NhbWUnLCAnc2F0aXNmaWVzJywgJ3NjaGVtYScsICdzY2hlbWEtYXR0cmlidXRlJywgJ3NjaGVtYS1lbGVtZW50JywgJ3Njb3JlJyxcbiAgICAgICAgICAgICAgICdzZWxmJywgJ3NlbnNpdGl2ZScsICdzZW50ZW5jZScsICdzZW50ZW5jZXMnLCAnc2VxdWVuY2UnLCAnc2tpcCcsICdzbGlkaW5nJywgJ3NvbWUnLCAnc3RhYmxlJyxcbiAgICAgICAgICAgICAgICdzdGFydCcsICdzdGVtbWluZycsICdzdG9wJywgJ3N0cmljdCcsICdzdHJpcCcsICdzd2l0Y2gnLCAndGV4dCcsICd0aGVuJywgJ3RoZXNhdXJ1cycsICd0aW1lcycsXG4gICAgICAgICAgICAgICAndG8nLCAndHJhbnNmb3JtJywgJ3RyZWF0JywgJ3RyeScsICd0dW1ibGluZycsICd0eXBlJywgJ3R5cGVzd2l0Y2gnLCAndW5pb24nLCAndW5vcmRlcmVkJyxcbiAgICAgICAgICAgICAgICd1cGRhdGUnLCAndXBkYXRpbmcnLCAndXBwZXJjYXNlJywgJ3VzaW5nJywgJ3ZhbGlkYXRlJywgJ3ZhbHVlJywgJ3ZhcmlhYmxlJywgJ3ZlcnNpb24nLFxuICAgICAgICAgICAgICAgJ3dlaWdodCcsICd3aGVuJywgJ3doZXJlJywgJ3dpbGRjYXJkcycsICd3aW5kb3cnLCAnd2l0aCcsICd3aXRob3V0JywgJ3dvcmQnLCAnd29yZHMnLCAneHF1ZXJ5J107XG4gIGZvcih2YXIgaT0wLCBsPWJhc2ljLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtiYXNpY1tpXV0gPSBrdyhiYXNpY1tpXSk7fTtcblxuICAvLyBhIGxpc3Qgb2YgdHlwZXMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gIC8vIHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICB2YXIgdHlwZXMgPSBbJ3hzOmFueUF0b21pY1R5cGUnLCAneHM6YW55U2ltcGxlVHlwZScsICd4czphbnlUeXBlJywgJ3hzOmFueVVSSScsXG4gICAgICAgICAgICAgICAneHM6YmFzZTY0QmluYXJ5JywgJ3hzOmJvb2xlYW4nLCAneHM6Ynl0ZScsICd4czpkYXRlJywgJ3hzOmRhdGVUaW1lJywgJ3hzOmRhdGVUaW1lU3RhbXAnLFxuICAgICAgICAgICAgICAgJ3hzOmRheVRpbWVEdXJhdGlvbicsICd4czpkZWNpbWFsJywgJ3hzOmRvdWJsZScsICd4czpkdXJhdGlvbicsICd4czpFTlRJVElFUycsICd4czpFTlRJVFknLFxuICAgICAgICAgICAgICAgJ3hzOmZsb2F0JywgJ3hzOmdEYXknLCAneHM6Z01vbnRoJywgJ3hzOmdNb250aERheScsICd4czpnWWVhcicsICd4czpnWWVhck1vbnRoJywgJ3hzOmhleEJpbmFyeScsXG4gICAgICAgICAgICAgICAneHM6SUQnLCAneHM6SURSRUYnLCAneHM6SURSRUZTJywgJ3hzOmludCcsICd4czppbnRlZ2VyJywgJ3hzOml0ZW0nLCAneHM6amF2YScsICd4czpsYW5ndWFnZScsXG4gICAgICAgICAgICAgICAneHM6bG9uZycsICd4czpOYW1lJywgJ3hzOk5DTmFtZScsICd4czpuZWdhdGl2ZUludGVnZXInLCAneHM6Tk1UT0tFTicsICd4czpOTVRPS0VOUycsXG4gICAgICAgICAgICAgICAneHM6bm9uTmVnYXRpdmVJbnRlZ2VyJywgJ3hzOm5vblBvc2l0aXZlSW50ZWdlcicsICd4czpub3JtYWxpemVkU3RyaW5nJywgJ3hzOk5PVEFUSU9OJyxcbiAgICAgICAgICAgICAgICd4czpudW1lcmljJywgJ3hzOnBvc2l0aXZlSW50ZWdlcicsICd4czpwcmVjaXNpb25EZWNpbWFsJywgJ3hzOlFOYW1lJywgJ3hzOnNob3J0JywgJ3hzOnN0cmluZycsXG4gICAgICAgICAgICAgICAneHM6dGltZScsICd4czp0b2tlbicsICd4czp1bnNpZ25lZEJ5dGUnLCAneHM6dW5zaWduZWRJbnQnLCAneHM6dW5zaWduZWRMb25nJyxcbiAgICAgICAgICAgICAgICd4czp1bnNpZ25lZFNob3J0JywgJ3hzOnVudHlwZWQnLCAneHM6dW50eXBlZEF0b21pYycsICd4czp5ZWFyTW9udGhEdXJhdGlvbiddO1xuICBmb3IodmFyIGk9MCwgbD10eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbdHlwZXNbaV1dID0gYXRvbTt9O1xuXG4gIC8vIGVhY2ggb3BlcmF0b3Igd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcIm9wZXJhdG9yXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgdmFyIG9wZXJhdG9ycyA9IFsnZXEnLCAnbmUnLCAnbHQnLCAnbGUnLCAnZ3QnLCAnZ2UnLCAnOj0nLCAnPScsICc+JywgJz49JywgJzwnLCAnPD0nLCAnLicsICd8JywgJz8nLCAnYW5kJywgJ29yJywgJ2RpdicsICdpZGl2JywgJ21vZCcsICcqJywgJy8nLCAnKycsICctJ107XG4gIGZvcih2YXIgaT0wLCBsPW9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbb3BlcmF0b3JzW2ldXSA9IG9wZXJhdG9yO307XG5cbiAgLy8gZWFjaCBheGlzX3NwZWNpZmllcnMgd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcImF4aXNfc3BlY2lmaWVyXCIsIHN0eWxlOiBcInF1YWxpZmllclwifVxuICB2YXIgYXhpc19zcGVjaWZpZXJzID0gW1wic2VsZjo6XCIsIFwiYXR0cmlidXRlOjpcIiwgXCJjaGlsZDo6XCIsIFwiZGVzY2VuZGFudDo6XCIsIFwiZGVzY2VuZGFudC1vci1zZWxmOjpcIiwgXCJwYXJlbnQ6OlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW5jZXN0b3I6OlwiLCBcImFuY2VzdG9yLW9yLXNlbGY6OlwiLCBcImZvbGxvd2luZzo6XCIsIFwicHJlY2VkaW5nOjpcIiwgXCJmb2xsb3dpbmctc2libGluZzo6XCIsIFwicHJlY2VkaW5nLXNpYmxpbmc6OlwiXTtcbiAgZm9yKHZhciBpPTAsIGw9YXhpc19zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtheGlzX3NwZWNpZmllcnNbaV1dID0gcXVhbGlmaWVyOyB9O1xuXG4gIHJldHVybiBrd09iajtcbn0oKTtcblxuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyB0aGUgcHJpbWFyeSBtb2RlIHRva2VuaXplclxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKSxcbiAgICAgIG1pZ2h0QmVGdW5jdGlvbiA9IGZhbHNlLFxuICAgICAgaXNFUU5hbWUgPSBpc0VRTmFtZUFoZWFkKHN0cmVhbSk7XG5cbiAgLy8gYW4gWE1MIHRhZyAoaWYgbm90IGluIHNvbWUgc3ViLCBjaGFpbmVkIHRva2VuaXplcilcbiAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiIS0tXCIsIHRydWUpKVxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuWE1MQ29tbWVudCk7XG5cbiAgICBpZihzdHJlYW0ubWF0Y2goXCIhW0NEQVRBXCIsIGZhbHNlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNEQVRBO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuXG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiP1wiLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblByZVByb2Nlc3NpbmcpO1xuICAgIH1cblxuICAgIHZhciBpc2Nsb3NlID0gc3RyZWFtLmVhdChcIi9cIik7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgdmFyIHRhZ05hbWUgPSBcIlwiLCBjO1xuICAgIHdoaWxlICgoYyA9IHN0cmVhbS5lYXQoL1teXFxzXFx1MDBhMD08PlxcXCJcXCdcXC8/XS8pKSkgdGFnTmFtZSArPSBjO1xuXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVGFnKHRhZ05hbWUsIGlzY2xvc2UpKTtcbiAgfVxuICAvLyBzdGFydCBjb2RlIGJsb2NrXG4gIGVsc2UgaWYoY2ggPT0gXCJ7XCIpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvZGVibG9ja1wifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gZW5kIGNvZGUgYmxvY2tcbiAgZWxzZSBpZihjaCA9PSBcIn1cIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGlmIHdlJ3JlIGluIGFuIFhNTCBibG9ja1xuICBlbHNlIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHtcbiAgICBpZihjaCA9PSBcIj5cIilcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIGVsc2UgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cbiAgLy8gaWYgYSBudW1iZXJcbiAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKik/KD86RVsrXFwtXT9cXGQrKT8vKTtcbiAgICByZXR1cm4gXCJhdG9tXCI7XG4gIH1cbiAgLy8gY29tbWVudCBzdGFydFxuICBlbHNlIGlmIChjaCA9PT0gXCIoXCIgJiYgc3RyZWFtLmVhdChcIjpcIikpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvbW1lbnRcIn0pO1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICB9XG4gIC8vIHF1b3RlZCBzdHJpbmdcbiAgZWxzZSBpZiAoIWlzRVFOYW1lICYmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpKVxuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCkpO1xuICAvLyB2YXJpYWJsZVxuICBlbHNlIGlmKGNoID09PSBcIiRcIikge1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblZhcmlhYmxlKTtcbiAgfVxuICAvLyBhc3NpZ25tZW50XG4gIGVsc2UgaWYoY2ggPT09XCI6XCIgJiYgc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cbiAgLy8gb3BlbiBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIihcIikge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwicGFyZW5cIn0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGNsb3NlIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiKVwiKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gb3BlbiBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIltcIikge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiYnJhY2tldFwifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gY2xvc2UgcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCJdXCIpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjaCkgJiYga2V5d29yZHNbY2hdO1xuXG4gICAgLy8gaWYgdGhlcmUncyBhIEVRTmFtZSBhaGVhZCwgY29uc3VtZSB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHBvcnRpb24sIGl0J3MgbGlrZWx5IGEgZnVuY3Rpb25cbiAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcXCInKSB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXCInKXt9XG4gICAgaWYoaXNFUU5hbWUgJiYgY2ggPT09ICdcXCcnKSB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXFwnJyl7fVxuXG4gICAgLy8gZ29iYmxlIHVwIGEgd29yZCBpZiB0aGUgY2hhcmFjdGVyIGlzIG5vdCBrbm93blxuICAgIGlmKCFrbm93bikgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkXy1dLyk7XG5cbiAgICAvLyBnb2JibGUgYSBjb2xvbiBpbiB0aGUgY2FzZSB0aGF0IGlzIGEgbGliIGZ1bmMgdHlwZSBjYWxsIGZuOmRvY1xuICAgIHZhciBmb3VuZENvbG9uID0gc3RyZWFtLmVhdChcIjpcIik7XG5cbiAgICAvLyBpZiB0aGVyZSdzIG5vdCBhIHNlY29uZCBjb2xvbiwgZ29iYmxlIGFub3RoZXIgd29yZC4gT3RoZXJ3aXNlLCBpdCdzIHByb2JhYmx5IGFuIGF4aXMgc3BlY2lmaWVyXG4gICAgLy8gd2hpY2ggc2hvdWxkIGdldCBtYXRjaGVkIGFzIGEga2V5d29yZFxuICAgIGlmKCFzdHJlYW0uZWF0KFwiOlwiKSAmJiBmb3VuZENvbG9uKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG5leHQgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGFuIG9wZW4gcGFyZW4sIHRoaXMgaXMgcHJvYmFibHkgYSBmdW5jdGlvbiAoaWYgbm90IGEga2V5d29yZCBvZiBvdGhlciBzb3J0KVxuICAgIGlmKHN0cmVhbS5tYXRjaCgvXlsgXFx0XSpcXCgvLCBmYWxzZSkpIHtcbiAgICAgIG1pZ2h0QmVGdW5jdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIC8vIGlzIHRoZSB3b3JkIGEga2V5d29yZD9cbiAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSAmJiBrZXl3b3Jkc1t3b3JkXTtcblxuICAgIC8vIGlmIHdlIHRoaW5rIGl0J3MgYSBmdW5jdGlvbiBjYWxsIGJ1dCBub3QgeWV0IGtub3duLFxuICAgIC8vIHNldCBzdHlsZSB0byB2YXJpYWJsZSBmb3Igbm93IGZvciBsYWNrIG9mIHNvbWV0aGluZyBiZXR0ZXJcbiAgICBpZihtaWdodEJlRnVuY3Rpb24gJiYgIWtub3duKSBrbm93biA9IHt0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIiwgc3R5bGU6IFwiZGVmXCJ9O1xuXG4gICAgLy8gaWYgdGhlIHByZXZpb3VzIHdvcmQgd2FzIGVsZW1lbnQsIGF0dHJpYnV0ZSwgYXhpcyBzcGVjaWZpZXIsIHRoaXMgd29yZCBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhhdFxuICAgIGlmKGlzSW5YbWxDb25zdHJ1Y3RvcihzdGF0ZSkpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9XG4gICAgLy8gYXMgcHJldmlvdXNseSBjaGVja2VkLCBpZiB0aGUgd29yZCBpcyBlbGVtZW50LGF0dHJpYnV0ZSwgYXhpcyBzcGVjaWZpZXIsIGNhbGwgaXQgYW4gXCJ4bWxjb25zdHJ1Y3RvclwiIGFuZFxuICAgIC8vIHB1c2ggdGhlIHN0YWNrIHNvIHdlIGtub3cgdG8gbG9vayBmb3IgaXQgb24gdGhlIG5leHQgd29yZFxuICAgIGlmKHdvcmQgPT0gXCJlbGVtZW50XCIgfHwgd29yZCA9PSBcImF0dHJpYnV0ZVwiIHx8IGtub3duLnR5cGUgPT0gXCJheGlzX3NwZWNpZmllclwiKSBwdXNoU3RhdGVTdGFjayhzdGF0ZSwge3R5cGU6IFwieG1sY29uc3RydWN0b3JcIn0pO1xuXG4gICAgLy8gaWYgdGhlIHdvcmQgaXMga25vd24sIHJldHVybiB0aGUgZGV0YWlscyBvZiB0aGF0IGVsc2UganVzdCBjYWxsIHRoaXMgYSBnZW5lcmljICd3b3JkJ1xuICAgIHJldHVybiBrbm93biA/IGtub3duLnN0eWxlIDogXCJ2YXJpYWJsZVwiO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb21tZW50cywgaW5jbHVkaW5nIG5lc3RlZFxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIG1heWJlTmVzdGVkID0gZmFsc2UsIG5lc3RlZENvdW50ID0gMCwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIpXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIGlmKG5lc3RlZENvdW50ID4gMClcbiAgICAgICAgbmVzdGVkQ291bnQtLTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYoY2ggPT0gXCI6XCIgJiYgbWF5YmVOZXN0ZWQpIHtcbiAgICAgIG5lc3RlZENvdW50Kys7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiOlwiKTtcbiAgICBtYXliZU5lc3RlZCA9IChjaCA9PSBcIihcIik7XG4gIH1cblxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbi8vIHRva2VuaXplciBmb3Igc3RyaW5nIGxpdGVyYWxzXG4vLyBvcHRpb25hbGx5IHBhc3MgYSB0b2tlbml6ZXIgZnVuY3Rpb24gdG8gc2V0IHN0YXRlLnRva2VuaXplIGJhY2sgdG8gd2hlbiBmaW5pc2hlZFxuZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUsIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2g7XG5cbiAgICBpZihpc0luU3RyaW5nKHN0YXRlKSAmJiBzdHJlYW0uY3VycmVudCgpID09IHF1b3RlKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIGlmKGYpIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IHF1b3RlLCB0b2tlbml6ZTogdG9rZW5TdHJpbmcocXVvdGUsIGYpIH0pO1xuXG4gICAgLy8gaWYgd2UncmUgaW4gYSBzdHJpbmcgYW5kIGluIGFuIFhNTCBibG9jaywgYWxsb3cgYW4gZW1iZWRkZWQgY29kZSBibG9ja1xuICAgIGlmKHN0cmVhbS5tYXRjaChcIntcIiwgZmFsc2UpICYmIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG5cbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gIHF1b3RlKSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICBpZihmKSBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIGEgc3RyaW5nIGFuZCBpbiBhbiBYTUwgYmxvY2ssIGFsbG93IGFuIGVtYmVkZGVkIGNvZGUgYmxvY2sgaW4gYW4gYXR0cmlidXRlXG4gICAgICAgIGlmKHN0cmVhbS5tYXRjaChcIntcIiwgZmFsc2UpICYmIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH07XG59XG5cbi8vIHRva2VuaXplciBmb3IgdmFyaWFibGVzXG5mdW5jdGlvbiB0b2tlblZhcmlhYmxlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGlzVmFyaWFibGVDaGFyID0gL1tcXHdcXCRfLV0vO1xuXG4gIC8vIGEgdmFyaWFibGUgbWF5IHN0YXJ0IHdpdGggYSBxdW90ZWQgRVFOYW1lIHNvIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBxdW90ZSwgY29uc3VtZSB0byB0aGUgbmV4dCBxdW90ZVxuICBpZihzdHJlYW0uZWF0KFwiXFxcIlwiKSkge1xuICAgIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcXFwiJyl7fTtcbiAgICBzdHJlYW0uZWF0KFwiOlwiKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNWYXJpYWJsZUNoYXIpO1xuICAgIGlmKCFzdHJlYW0ubWF0Y2goXCI6PVwiLCBmYWxzZSkpIHN0cmVhbS5lYXQoXCI6XCIpO1xuICB9XG4gIHN0cmVhbS5lYXRXaGlsZShpc1ZhcmlhYmxlQ2hhcik7XG4gIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xufVxuXG4vLyB0b2tlbml6ZXIgZm9yIFhNTCB0YWdzXG5mdW5jdGlvbiB0b2tlblRhZyhuYW1lLCBpc2Nsb3NlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgaWYoaXNjbG9zZSAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cbiAgICAvLyBzZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYXR0cmlidXRlcz9cbiAgICBpZighc3RyZWFtLmVhdChcIi9cIikpXG4gICAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcInRhZ1wiLCBuYW1lOiBuYW1lLCB0b2tlbml6ZTogdG9rZW5CYXNlfSk7XG4gICAgaWYoIXN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQXR0cmlidXRlO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgfVxuICAgIHJldHVybiBcInRhZ1wiO1xuICB9O1xufVxuXG4vLyB0b2tlbml6ZXIgZm9yIFhNTCBhdHRyaWJ1dGVzXG5mdW5jdGlvbiB0b2tlbkF0dHJpYnV0ZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICBpZihpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICBpZihpc0luWG1sQmxvY2soc3RhdGUpKSBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgfVxuICBpZihjaCA9PSBcIj5cIikge1xuICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBcInRhZ1wiO1xuICB9XG4gIGlmKGNoID09IFwiPVwiKVxuICAgIHJldHVybiBudWxsO1xuICAvLyBxdW90ZWQgc3RyaW5nXG4gIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKVxuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCwgdG9rZW5BdHRyaWJ1dGUpKTtcblxuICBpZighaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSlcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImF0dHJpYnV0ZVwiLCB0b2tlbml6ZTogdG9rZW5BdHRyaWJ1dGV9KTtcblxuICBzdHJlYW0uZWF0KC9bYS16QS1aXzpdLyk7XG4gIHN0cmVhbS5lYXRXaGlsZSgvWy1hLXpBLVowLTlfOi5dLyk7XG4gIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gIC8vIHRoZSBjYXNlIHdoZXJlIHRoZSBhdHRyaWJ1dGUgaGFzIG5vdCB2YWx1ZSBhbmQgdGhlIHRhZyB3YXMgY2xvc2VkXG4gIGlmKHN0cmVhbS5tYXRjaChcIj5cIiwgZmFsc2UpIHx8IHN0cmVhbS5tYXRjaChcIi9cIiwgZmFsc2UpKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIH1cblxuICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbn1cblxuLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG5mdW5jdGlvbiB0b2tlblhNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIiwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIGhhbmRsZSBDREFUQVxuZnVuY3Rpb24gdG9rZW5DREFUQShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIl1cIiAmJiBzdHJlYW0ubWF0Y2goXCJdXCIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGFuZGxlIHByZXByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG5mdW5jdGlvbiB0b2tlblByZVByb2Nlc3Npbmcoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCI/XCIgJiYgc3RyZWFtLm1hdGNoKFwiPlwiLCB0cnVlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBmdW5jdGlvbnMgdG8gdGVzdCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBzdGF0ZVxuZnVuY3Rpb24gaXNJblhtbEJsb2NrKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInRhZ1wiKTsgfVxuZnVuY3Rpb24gaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcImF0dHJpYnV0ZVwiKTsgfVxuZnVuY3Rpb24gaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInhtbGNvbnN0cnVjdG9yXCIpOyB9XG5mdW5jdGlvbiBpc0luU3RyaW5nKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInN0cmluZ1wiKTsgfVxuXG5mdW5jdGlvbiBpc0VRTmFtZUFoZWFkKHN0cmVhbSkge1xuICAvLyBhc3N1bWUgd2UndmUgYWxyZWFkeSBlYXRlbiBhIHF1b3RlIChcIilcbiAgaWYoc3RyZWFtLmN1cnJlbnQoKSA9PT0gJ1wiJylcbiAgICByZXR1cm4gc3RyZWFtLm1hdGNoKC9eW15cXFwiXStcXFwiXFw6LywgZmFsc2UpO1xuICBlbHNlIGlmKHN0cmVhbS5jdXJyZW50KCkgPT09ICdcXCcnKVxuICAgIHJldHVybiBzdHJlYW0ubWF0Y2goL15bXlxcXCJdK1xcJ1xcOi8sIGZhbHNlKTtcbiAgZWxzZVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbihzdGF0ZSwgdHlwZSkge1xuICByZXR1cm4gKHN0YXRlLnN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGggLSAxXS50eXBlID09IHR5cGUpO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgbmV3U3RhdGUpIHtcbiAgc3RhdGUuc3RhY2sucHVzaChuZXdTdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFN0YXRlU3RhY2soc3RhdGUpIHtcbiAgc3RhdGUuc3RhY2sucG9wKCk7XG4gIHZhciByZWluc3RhdGVUb2tlbml6ZSA9IHN0YXRlLnN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGgtMV0udG9rZW5pemU7XG4gIHN0YXRlLnRva2VuaXplID0gcmVpbnN0YXRlVG9rZW5pemUgfHwgdG9rZW5CYXNlO1xufVxuXG4vLyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgbW9kZSBBUElcbmV4cG9ydCBjb25zdCB4UXVlcnkgPSB7XG4gIG5hbWU6IFwieHF1ZXJ5XCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgY2M6IFtdLFxuICAgICAgc3RhY2s6IFtdXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtibG9jazoge29wZW46IFwiKDpcIiwgY2xvc2U6IFwiOilcIn19XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/xquery.js\n"));

/***/ })

}]);