"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_haxe_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/haxe.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haxe.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   haxe: function() { return /* binding */ haxe; },\n/* harmony export */   hxml: function() { return /* binding */ hxml; }\n/* harmony export */ });\n// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nconst haxe = {\n  name: \"haxe\",\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nconst hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9oYXhlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSx1Q0FBdUMsNEJBQTRCLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCLE1BQU07QUFDM0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9COztBQUV4QztBQUNBOztB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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2hheGUuanM/ZDg3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUb2tlbml6ZXJcblxuZnVuY3Rpb24ga3codHlwZSkge3JldHVybiB7dHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwifTt9XG52YXIgQSA9IGt3KFwia2V5d29yZCBhXCIpLCBCID0ga3coXCJrZXl3b3JkIGJcIiksIEMgPSBrdyhcImtleXdvcmQgY1wiKTtcbnZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIiksIGF0b20gPSB7dHlwZTogXCJhdG9tXCIsIHN0eWxlOiBcImF0b21cIn0sIGF0dHJpYnV0ZSA9IHt0eXBlOlwiYXR0cmlidXRlXCIsIHN0eWxlOiBcImF0dHJpYnV0ZVwifTtcbnZhciB0eXBlID0ga3coXCJ0eXBlZGVmXCIpO1xudmFyIGtleXdvcmRzID0ge1xuICBcImlmXCI6IEEsIFwid2hpbGVcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQixcbiAgXCJyZXR1cm5cIjogQywgXCJicmVha1wiOiBDLCBcImNvbnRpbnVlXCI6IEMsIFwibmV3XCI6IEMsIFwidGhyb3dcIjogQyxcbiAgXCJ2YXJcIjoga3coXCJ2YXJcIiksIFwiaW5saW5lXCI6YXR0cmlidXRlLCBcInN0YXRpY1wiOiBhdHRyaWJ1dGUsIFwidXNpbmdcIjprdyhcImltcG9ydFwiKSxcbiAgXCJwdWJsaWNcIjogYXR0cmlidXRlLCBcInByaXZhdGVcIjogYXR0cmlidXRlLCBcImNhc3RcIjoga3coXCJjYXN0XCIpLCBcImltcG9ydFwiOiBrdyhcImltcG9ydFwiKSwgXCJtYWNyb1wiOiBrdyhcIm1hY3JvXCIpLFxuICBcImZ1bmN0aW9uXCI6IGt3KFwiZnVuY3Rpb25cIiksIFwiY2F0Y2hcIjoga3coXCJjYXRjaFwiKSwgXCJ1bnR5cGVkXCI6IGt3KFwidW50eXBlZFwiKSwgXCJjYWxsYmFja1wiOiBrdyhcImNiXCIpLFxuICBcImZvclwiOiBrdyhcImZvclwiKSwgXCJzd2l0Y2hcIjoga3coXCJzd2l0Y2hcIiksIFwiY2FzZVwiOiBrdyhcImNhc2VcIiksIFwiZGVmYXVsdFwiOiBrdyhcImRlZmF1bHRcIiksXG4gIFwiaW5cIjogb3BlcmF0b3IsIFwibmV2ZXJcIjoga3coXCJwcm9wZXJ0eV9hY2Nlc3NcIiksIFwidHJhY2VcIjprdyhcInRyYWNlXCIpLFxuICBcImNsYXNzXCI6IHR5cGUsIFwiYWJzdHJhY3RcIjp0eXBlLCBcImVudW1cIjp0eXBlLCBcImludGVyZmFjZVwiOnR5cGUsIFwidHlwZWRlZlwiOnR5cGUsIFwiZXh0ZW5kc1wiOnR5cGUsIFwiaW1wbGVtZW50c1wiOnR5cGUsIFwiZHluYW1pY1wiOnR5cGUsXG4gIFwidHJ1ZVwiOiBhdG9tLCBcImZhbHNlXCI6IGF0b20sIFwibnVsbFwiOiBhdG9tXG59O1xuXG52YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP3xdLztcblxuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiB0b1VuZXNjYXBlZChzdHJlYW0sIGVuZCkge1xuICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0O1xuICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKG5leHQgPT0gZW5kICYmICFlc2NhcGVkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gIH1cbn1cblxuLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuLy8gY29uc2luZyB1cCB0b25zIG9mIG9iamVjdHMuXG52YXIgdHlwZSwgY29udGVudDtcbmZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgdHlwZSA9IHRwOyBjb250ZW50ID0gY29udDtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBoYXhlVG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgaGF4ZVRva2VuU3RyaW5nKGNoKSk7XG4gIH0gZWxzZSBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8udGVzdChjaCkpIHtcbiAgICByZXR1cm4gcmV0KGNoKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0uZWF0KC94L2kpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkYS1mXS9pKTtcbiAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpIHx8IGNoID09IFwiLVwiICYmIHN0cmVhbS5lYXQoL1xcZC8pKSB7XG4gICAgc3RyZWFtLm1hdGNoKC9eXFxkKig/OlxcLlxcZCooPyFcXC4pKT8oPzpbZUVdWytcXC1dP1xcZCspPy8pO1xuICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gIH0gZWxzZSBpZiAoc3RhdGUucmVBbGxvd2VkICYmIChjaCA9PSBcIn5cIiAmJiBzdHJlYW0uZWF0KC9cXC8vKSkpIHtcbiAgICB0b1VuZXNjYXBlZChzdHJlYW0sIFwiL1wiKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tnaW1zdV0vKTtcbiAgICByZXR1cm4gcmV0KFwicmVnZXhwXCIsIFwic3RyaW5nLnNwZWNpYWxcIik7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCBoYXhlVG9rZW5Db21tZW50KTtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgbnVsbCwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiByZXQoXCJjb25kaXRpb25hbFwiLCBcIm1ldGFcIik7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCJAXCIpIHtcbiAgICBzdHJlYW0uZWF0KC86Lyk7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X10vKTtcbiAgICByZXR1cm4gcmV0IChcIm1ldGFkYXRhXCIsIFwibWV0YVwiKTtcbiAgfSBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgcmV0dXJuIHJldChcIm9wZXJhdG9yXCIsIG51bGwsIHN0cmVhbS5jdXJyZW50KCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciB3b3JkO1xuICAgIGlmKC9bQS1aXS8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd188Pl0vKTtcbiAgICAgIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgcmV0dXJuIHJldChcInR5cGVcIiwgXCJ0eXBlXCIsIHdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXS8pO1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLCBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpICYmIGtleXdvcmRzW3dvcmRdO1xuICAgICAgcmV0dXJuIChrbm93biAmJiBzdGF0ZS5rd0FsbG93ZWQpID8gcmV0KGtub3duLnR5cGUsIGtub3duLnN0eWxlLCB3b3JkKSA6XG4gICAgICAgIHJldChcInZhcmlhYmxlXCIsIFwidmFyaWFibGVcIiwgd29yZCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhheGVUb2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0b1VuZXNjYXBlZChzdHJlYW0sIHF1b3RlKSlcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaGF4ZVRva2VuQmFzZTtcbiAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBoYXhlVG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGhheGVUb2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICB9XG4gIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbn1cblxuLy8gUGFyc2VyXG5cbnZhciBhdG9taWNUeXBlcyA9IHtcImF0b21cIjogdHJ1ZSwgXCJudW1iZXJcIjogdHJ1ZSwgXCJ2YXJpYWJsZVwiOiB0cnVlLCBcInN0cmluZ1wiOiB0cnVlLCBcInJlZ2V4cFwiOiB0cnVlfTtcblxuZnVuY3Rpb24gSGF4ZUxleGljYWwoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYsIGluZm8pIHtcbiAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmV2ID0gcHJldjtcbiAgdGhpcy5pbmZvID0gaW5mbztcbiAgaWYgKGFsaWduICE9IG51bGwpIHRoaXMuYWxpZ24gPSBhbGlnbjtcbn1cblxuZnVuY3Rpb24gaW5TY29wZShzdGF0ZSwgdmFybmFtZSkge1xuICBmb3IgKHZhciB2ID0gc3RhdGUubG9jYWxWYXJzOyB2OyB2ID0gdi5uZXh0KVxuICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGF4ZShzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSkge1xuICB2YXIgY2MgPSBzdGF0ZS5jYztcbiAgLy8gQ29tbXVuaWNhdGUgb3VyIGNvbnRleHQgdG8gdGhlIGNvbWJpbmF0b3JzLlxuICAvLyAoTGVzcyB3YXN0ZWZ1bCB0aGFuIGNvbnNpbmcgdXAgYSBodW5kcmVkIGNsb3N1cmVzIG9uIGV2ZXJ5IGNhbGwuKVxuICBjeC5zdGF0ZSA9IHN0YXRlOyBjeC5zdHJlYW0gPSBzdHJlYW07IGN4Lm1hcmtlZCA9IG51bGwsIGN4LmNjID0gY2M7XG5cbiAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IHRydWU7XG5cbiAgd2hpbGUodHJ1ZSkge1xuICAgIHZhciBjb21iaW5hdG9yID0gY2MubGVuZ3RoID8gY2MucG9wKCkgOiBzdGF0ZW1lbnQ7XG4gICAgaWYgKGNvbWJpbmF0b3IodHlwZSwgY29udGVudCkpIHtcbiAgICAgIHdoaWxlKGNjLmxlbmd0aCAmJiBjY1tjYy5sZW5ndGggLSAxXS5sZXgpXG4gICAgICAgIGNjLnBvcCgpKCk7XG4gICAgICBpZiAoY3gubWFya2VkKSByZXR1cm4gY3gubWFya2VkO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGluU2NvcGUoc3RhdGUsIGNvbnRlbnQpKSByZXR1cm4gXCJ2YXJpYWJsZU5hbWUubG9jYWxcIjtcbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpbXBvcnRlZChzdGF0ZSwgY29udGVudCkpIHJldHVybiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCI7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGltcG9ydGVkKHN0YXRlLCB0eXBlbmFtZSkge1xuICBpZiAoL1thLXpdLy50ZXN0KHR5cGVuYW1lLmNoYXJBdCgwKSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgbGVuID0gc3RhdGUuaW1wb3J0ZWR0eXBlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpPGxlbjsgaSsrKVxuICAgIGlmKHN0YXRlLmltcG9ydGVkdHlwZXNbaV09PXR5cGVuYW1lKSByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJpbXBvcnQoaW1wb3J0bmFtZSkge1xuICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgZm9yICh2YXIgdCA9IHN0YXRlLmltcG9ydGVkdHlwZXM7IHQ7IHQgPSB0Lm5leHQpXG4gICAgaWYodC5uYW1lID09IGltcG9ydG5hbWUpIHJldHVybjtcbiAgc3RhdGUuaW1wb3J0ZWR0eXBlcyA9IHsgbmFtZTogaW1wb3J0bmFtZSwgbmV4dDogc3RhdGUuaW1wb3J0ZWR0eXBlcyB9O1xufVxuLy8gQ29tYmluYXRvciB1dGlsc1xuXG52YXIgY3ggPSB7c3RhdGU6IG51bGwsIGNvbHVtbjogbnVsbCwgbWFya2VkOiBudWxsLCBjYzogbnVsbH07XG5mdW5jdGlvbiBwYXNzKCkge1xuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG59XG5mdW5jdGlvbiBjb250KCkge1xuICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaW5MaXN0KG5hbWUsIGxpc3QpIHtcbiAgZm9yICh2YXIgdiA9IGxpc3Q7IHY7IHYgPSB2Lm5leHQpXG4gICAgaWYgKHYubmFtZSA9PSBuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXIodmFybmFtZSkge1xuICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgaWYgKHN0YXRlLmNvbnRleHQpIHtcbiAgICBjeC5tYXJrZWQgPSBcImRlZlwiO1xuICAgIGlmIChpbkxpc3QodmFybmFtZSwgc3RhdGUubG9jYWxWYXJzKSkgcmV0dXJuO1xuICAgIHN0YXRlLmxvY2FsVmFycyA9IHtuYW1lOiB2YXJuYW1lLCBuZXh0OiBzdGF0ZS5sb2NhbFZhcnN9O1xuICB9IGVsc2UgaWYgKHN0YXRlLmdsb2JhbFZhcnMpIHtcbiAgICBpZiAoaW5MaXN0KHZhcm5hbWUsIHN0YXRlLmdsb2JhbFZhcnMpKSByZXR1cm47XG4gICAgc3RhdGUuZ2xvYmFsVmFycyA9IHtuYW1lOiB2YXJuYW1lLCBuZXh0OiBzdGF0ZS5nbG9iYWxWYXJzfTtcbiAgfVxufVxuXG4vLyBDb21iaW5hdG9yc1xuXG52YXIgZGVmYXVsdFZhcnMgPSB7bmFtZTogXCJ0aGlzXCIsIG5leHQ6IG51bGx9O1xuZnVuY3Rpb24gcHVzaGNvbnRleHQoKSB7XG4gIGlmICghY3guc3RhdGUuY29udGV4dCkgY3guc3RhdGUubG9jYWxWYXJzID0gZGVmYXVsdFZhcnM7XG4gIGN4LnN0YXRlLmNvbnRleHQgPSB7cHJldjogY3guc3RhdGUuY29udGV4dCwgdmFyczogY3guc3RhdGUubG9jYWxWYXJzfTtcbn1cbmZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gIGN4LnN0YXRlLmxvY2FsVmFycyA9IGN4LnN0YXRlLmNvbnRleHQudmFycztcbiAgY3guc3RhdGUuY29udGV4dCA9IGN4LnN0YXRlLmNvbnRleHQucHJldjtcbn1cbnBvcGNvbnRleHQubGV4ID0gdHJ1ZTtcbmZ1bmN0aW9uIHB1c2hsZXgodHlwZSwgaW5mbykge1xuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgc3RhdGUubGV4aWNhbCA9IG5ldyBIYXhlTGV4aWNhbChzdGF0ZS5pbmRlbnRlZCwgY3guc3RyZWFtLmNvbHVtbigpLCB0eXBlLCBudWxsLCBzdGF0ZS5sZXhpY2FsLCBpbmZvKTtcbiAgfTtcbiAgcmVzdWx0LmxleCA9IHRydWU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwb3BsZXgoKSB7XG4gIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICBpZiAoc3RhdGUubGV4aWNhbC5wcmV2KSB7XG4gICAgaWYgKHN0YXRlLmxleGljYWwudHlwZSA9PSBcIilcIilcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUubGV4aWNhbC5pbmRlbnRlZDtcbiAgICBzdGF0ZS5sZXhpY2FsID0gc3RhdGUubGV4aWNhbC5wcmV2O1xuICB9XG59XG5wb3BsZXgubGV4ID0gdHJ1ZTtcblxuZnVuY3Rpb24gZXhwZWN0KHdhbnRlZCkge1xuICBmdW5jdGlvbiBmKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSB3YW50ZWQpIHJldHVybiBjb250KCk7XG4gICAgZWxzZSBpZiAod2FudGVkID09IFwiO1wiKSByZXR1cm4gcGFzcygpO1xuICAgIGVsc2UgcmV0dXJuIGNvbnQoZik7XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIHN0YXRlbWVudCh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwiQFwiKSByZXR1cm4gY29udChtZXRhZGVmKTtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInZhcmRlZlwiKSwgdmFyZGVmMSwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGFcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cHJlc3Npb24sIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBwdXNoY29udGV4dCwgYmxvY2ssIHBvcGxleCwgcG9wY29udGV4dCk7XG4gIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udCgpO1xuICBpZiAodHlwZSA9PSBcImF0dHJpYnV0ZVwiKSByZXR1cm4gY29udChtYXliZWF0dHJpYnV0ZSk7XG4gIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICBpZiAodHlwZSA9PSBcImZvclwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwZWN0KFwiKFwiKSwgcHVzaGxleChcIilcIiksIGZvcnNwZWMxLCBleHBlY3QoXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wbGV4LCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlbGFiZWwpO1xuICBpZiAodHlwZSA9PSBcInN3aXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgcHVzaGxleChcIn1cIiwgXCJzd2l0Y2hcIiksIGV4cGVjdChcIntcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jaywgcG9wbGV4LCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcImNhc2VcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiOlwiKSk7XG4gIGlmICh0eXBlID09IFwiZGVmYXVsdFwiKSByZXR1cm4gY29udChleHBlY3QoXCI6XCIpKTtcbiAgaWYgKHR5cGUgPT0gXCJjYXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGNvbnRleHQsIGV4cGVjdChcIihcIiksIGZ1bmFyZywgZXhwZWN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50LCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICBpZiAodHlwZSA9PSBcImltcG9ydFwiKSByZXR1cm4gY29udChpbXBvcnRkZWYsIGV4cGVjdChcIjtcIikpO1xuICBpZiAodHlwZSA9PSBcInR5cGVkZWZcIikgcmV0dXJuIGNvbnQodHlwZWRlZik7XG4gIHJldHVybiBwYXNzKHB1c2hsZXgoXCJzdGF0XCIpLCBleHByZXNzaW9uLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xufVxuZnVuY3Rpb24gZXhwcmVzc2lvbih0eXBlKSB7XG4gIGlmIChhdG9taWNUeXBlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwidHlwZVwiICkgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICBpZiAodHlwZSA9PSBcImtleXdvcmQgY1wiKSByZXR1cm4gY29udChtYXliZWV4cHJlc3Npb24pO1xuICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiKSByZXR1cm4gY29udChleHByZXNzaW9uKTtcbiAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBjb21tYXNlcChtYXliZWV4cHJlc3Npb24sIFwiXVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBjb21tYXNlcChvYmpwcm9wLCBcIn1cIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gIHJldHVybiBjb250KCk7XG59XG5mdW5jdGlvbiBtYXliZWV4cHJlc3Npb24odHlwZSkge1xuICBpZiAodHlwZS5tYXRjaCgvWztcXH1cXClcXF0sXS8pKSByZXR1cm4gcGFzcygpO1xuICByZXR1cm4gcGFzcyhleHByZXNzaW9uKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVvcGVyYXRvcih0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgL1xcK1xcK3wtLS8udGVzdCh2YWx1ZSkpIHJldHVybiBjb250KG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm47XG4gIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAoZXhwcmVzc2lvbiwgXCIpXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIi5cIikgcmV0dXJuIGNvbnQocHJvcGVydHksIG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIl1cIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIG1heWJlYXR0cmlidXRlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJhdHRyaWJ1dGVcIikgcmV0dXJuIGNvbnQobWF5YmVhdHRyaWJ1dGUpO1xuICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJcIikgcmV0dXJuIGNvbnQodmFyZGVmMSk7XG59XG5cbmZ1bmN0aW9uIG1ldGFkZWYodHlwZSkge1xuICBpZih0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChtZXRhZGVmKTtcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICBpZih0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAobWV0YWFyZ3MsIFwiKVwiKSwgcG9wbGV4LCBzdGF0ZW1lbnQpO1xufVxuZnVuY3Rpb24gbWV0YWFyZ3ModHlwZSkge1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQoKTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0ZGVmICh0eXBlLCB2YWx1ZSkge1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZWdpc3RlcmltcG9ydCh2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgZWxzZSBpZih0eXBlID09IFwidmFyaWFibGVcIiB8fCB0eXBlID09IFwicHJvcGVydHlcIiB8fCB0eXBlID09IFwiLlwiIHx8IHZhbHVlID09IFwiKlwiKSByZXR1cm4gY29udChpbXBvcnRkZWYpO1xufVxuXG5mdW5jdGlvbiB0eXBlZGVmICh0eXBlLCB2YWx1ZSlcbntcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgL1tBLVpdLy50ZXN0KHZhbHVlLmNoYXJBdCgwKSkpIHsgcmVnaXN0ZXJpbXBvcnQodmFsdWUpOyByZXR1cm4gY29udCgpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJ0eXBlXCIgJiYgL1tBLVpdLy50ZXN0KHZhbHVlLmNoYXJBdCgwKSkpIHsgcmV0dXJuIGNvbnQoKTsgfVxufVxuXG5mdW5jdGlvbiBtYXliZWxhYmVsKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHBvcGxleCwgc3RhdGVtZW50KTtcbiAgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvciwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbn1cbmZ1bmN0aW9uIHByb3BlcnR5KHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7Y3gubWFya2VkID0gXCJwcm9wZXJ0eVwiOyByZXR1cm4gY29udCgpO31cbn1cbmZ1bmN0aW9uIG9ianByb3AodHlwZSkge1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChleHBlY3QoXCI6XCIpLCBleHByZXNzaW9uKTtcbn1cbmZ1bmN0aW9uIGNvbW1hc2VwKHdoYXQsIGVuZCkge1xuICBmdW5jdGlvbiBwcm9jZWVkKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQod2hhdCwgcHJvY2VlZCk7XG4gICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgIHJldHVybiBjb250KGV4cGVjdChlbmQpKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICBlbHNlIHJldHVybiBwYXNzKHdoYXQsIHByb2NlZWQpO1xuICB9O1xufVxuZnVuY3Rpb24gYmxvY2sodHlwZSkge1xuICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIGNvbnQoKTtcbiAgcmV0dXJuIHBhc3Moc3RhdGVtZW50LCBibG9jayk7XG59XG5mdW5jdGlvbiB2YXJkZWYxKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIil7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udCh0eXBldXNlLCB2YXJkZWYyKTt9XG4gIHJldHVybiBjb250KCk7XG59XG5mdW5jdGlvbiB2YXJkZWYyKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgdmFyZGVmMik7XG4gIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh2YXJkZWYxKTtcbn1cbmZ1bmN0aW9uIGZvcnNwZWMxKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICByZXR1cm4gY29udChmb3JpbiwgZXhwcmVzc2lvbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFzcygpXG4gIH1cbn1cbmZ1bmN0aW9uIGZvcmluKF90eXBlLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gXCJpblwiKSByZXR1cm4gY29udCgpO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25kZWYodHlwZSwgdmFsdWUpIHtcbiAgLy9mdW5jdGlvbiBuYW1lcyBzdGFydGluZyB3aXRoIHVwcGVyLWNhc2UgbGV0dGVycyBhcmUgcmVjb2duaXNlZCBhcyB0eXBlcywgc28gY2x1ZGdpbmcgdGhlbSB0b2dldGhlciBoZXJlLlxuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgdHlwZSA9PSBcInR5cGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO31cbiAgaWYgKHZhbHVlID09IFwibmV3XCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBwdXNoY29udGV4dCwgY29tbWFzZXAoZnVuYXJnLCBcIilcIiksIHBvcGxleCwgdHlwZXVzZSwgc3RhdGVtZW50LCBwb3Bjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHR5cGV1c2UodHlwZSkge1xuICBpZih0eXBlID09IFwiOlwiKSByZXR1cm4gY29udCh0eXBlc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHR5cGVzdHJpbmcodHlwZSkge1xuICBpZih0eXBlID09IFwidHlwZVwiKSByZXR1cm4gY29udCgpO1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQoKTtcbiAgaWYodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIGNvbW1hc2VwKHR5cGVwcm9wLCBcIn1cIiksIHBvcGxleCk7XG59XG5mdW5jdGlvbiB0eXBlcHJvcCh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCh0eXBldXNlKTtcbn1cbmZ1bmN0aW9uIGZ1bmFyZyh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KHR5cGV1c2UpO31cbn1cblxuLy8gSW50ZXJmYWNlXG5leHBvcnQgY29uc3QgaGF4ZSA9IHtcbiAgbmFtZTogXCJoYXhlXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGluZGVudFVuaXQpIHtcbiAgICB2YXIgZGVmYXVsdHR5cGVzID0gW1wiSW50XCIsIFwiRmxvYXRcIiwgXCJTdHJpbmdcIiwgXCJWb2lkXCIsIFwiU3RkXCIsIFwiQm9vbFwiLCBcIkR5bmFtaWNcIiwgXCJBcnJheVwiXTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICB0b2tlbml6ZTogaGF4ZVRva2VuQmFzZSxcbiAgICAgIHJlQWxsb3dlZDogdHJ1ZSxcbiAgICAgIGt3QWxsb3dlZDogdHJ1ZSxcbiAgICAgIGNjOiBbXSxcbiAgICAgIGxleGljYWw6IG5ldyBIYXhlTGV4aWNhbCgtaW5kZW50VW5pdCwgMCwgXCJibG9ja1wiLCBmYWxzZSksXG4gICAgICBpbXBvcnRlZHR5cGVzOiBkZWZhdWx0dHlwZXMsXG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgaW5kZW50ZWQ6IDBcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgIGlmICghc3RhdGUubGV4aWNhbC5oYXNPd25Qcm9wZXJ0eShcImFsaWduXCIpKVxuICAgICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gZmFsc2U7XG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwiY29tbWVudFwiKSByZXR1cm4gc3R5bGU7XG4gICAgc3RhdGUucmVBbGxvd2VkID0gISEodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcImtleXdvcmQgY1wiIHx8IHR5cGUubWF0Y2goL15bXFxbe31cXCgsOzpdJC8pKTtcbiAgICBzdGF0ZS5rd0FsbG93ZWQgPSB0eXBlICE9ICcuJztcbiAgICByZXR1cm4gcGFyc2VIYXhlKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgaWYgKHN0YXRlLnRva2VuaXplICE9IGhheGVUb2tlbkJhc2UpIHJldHVybiAwO1xuICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKSwgbGV4aWNhbCA9IHN0YXRlLmxleGljYWw7XG4gICAgaWYgKGxleGljYWwudHlwZSA9PSBcInN0YXRcIiAmJiBmaXJzdENoYXIgPT0gXCJ9XCIpIGxleGljYWwgPSBsZXhpY2FsLnByZXY7XG4gICAgdmFyIHR5cGUgPSBsZXhpY2FsLnR5cGUsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gdHlwZTtcbiAgICBpZiAodHlwZSA9PSBcInZhcmRlZlwiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIDQ7XG4gICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIiAmJiBmaXJzdENoYXIgPT0gXCJ7XCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkO1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJzdGF0XCIgfHwgdHlwZSA9PSBcImZvcm1cIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBjeC51bml0O1xuICAgIGVsc2UgaWYgKGxleGljYWwuaW5mbyA9PSBcInN3aXRjaFwiICYmICFjbG9zaW5nKVxuICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoL14oPzpjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KHRleHRBZnRlcikgPyBjeC51bml0IDogMiAqIGN4LnVuaXQpO1xuICAgIGVsc2UgaWYgKGxleGljYWwuYWxpZ24pIHJldHVybiBsZXhpY2FsLmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgIGVsc2UgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBjeC51bml0KTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypbe31dJC8sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLy9cIiwgYmxvY2s6IHtvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCJ9fVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaHhtbCA9IHtcbiAgbmFtZTogXCJoeG1sXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmaW5lOiBmYWxzZSxcbiAgICAgIGluU3RyaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgdmFyIHNvbCA9IHN0cmVhbS5zb2woKTtcblxuICAgIC8vLyogY29tbWVudHMgKi9cbiAgICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgaWYgKHNvbCAmJiBjaCA9PSBcIi1cIikge1xuICAgICAgdmFyIHN0eWxlID0gXCJ2YXJpYWJsZS0yXCI7XG5cbiAgICAgIHN0cmVhbS5lYXQoLy0vKTtcblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCItXCIpIHtcbiAgICAgICAgc3RyZWFtLmVhdCgvLS8pO1xuICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBhXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiRFwiKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1tEXS8pO1xuICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBjXCI7XG4gICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW0EtWl0vaSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgIGlmIChzdGF0ZS5pblN0cmluZyA9PSBmYWxzZSAmJiBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5TdHJpbmcgPT0gdHJ1ZSkge1xuICAgICAgaWYgKHN0cmVhbS5za2lwVG8oXCInXCIpKSB7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCInXCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/haxe.js\n"));

/***/ })

}]);