"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/trough@2.1.0";
exports.ids = ["vendor-chunks/trough@2.1.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/trough@2.1.0/node_modules/trough/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/trough@2.1.0/node_modules/trough/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trough: () => (/* binding */ trough),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */ /**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */ function trough() {\n    /** @type {Array<Middleware>} */ const fns = [];\n    /** @type {Pipeline} */ const pipeline = {\n        run,\n        use\n    };\n    return pipeline;\n    /** @type {Run} */ function run(...values) {\n        let middlewareIndex = -1;\n        /** @type {Callback} */ const callback = values.pop();\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"Expected function as last argument, not \" + callback);\n        }\n        next(null, ...values);\n        /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */ function next(error, ...output) {\n            const fn = fns[++middlewareIndex];\n            let index = -1;\n            if (error) {\n                callback(error);\n                return;\n            }\n            // Copy non-nullish input into values.\n            while(++index < values.length){\n                if (output[index] === null || output[index] === undefined) {\n                    output[index] = values[index];\n                }\n            }\n            // Save the newly created `output` for the next call.\n            values = output;\n            // Next or done.\n            if (fn) {\n                wrap(fn, next)(...output);\n            } else {\n                callback(null, ...output);\n            }\n        }\n    }\n    /** @type {Use} */ function use(middelware) {\n        if (typeof middelware !== \"function\") {\n            throw new TypeError(\"Expected `middelware` to be a function, not \" + middelware);\n        }\n        fns.push(middelware);\n        return pipeline;\n    }\n}\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */ function wrap(middleware, callback) {\n    /** @type {boolean} */ let called;\n    return wrapped;\n    /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */ function wrapped(...parameters) {\n        const fnExpectsCallback = middleware.length > parameters.length;\n        /** @type {any} */ let result;\n        if (fnExpectsCallback) {\n            parameters.push(done);\n        }\n        try {\n            result = middleware.apply(this, parameters);\n        } catch (error) {\n            const exception = /** @type {Error} */ error;\n            // Well, this is quite the pickle.\n            // `middleware` received a callback and called it synchronously, but that\n            // threw an error.\n            // The only thing left to do is to throw the thing instead.\n            if (fnExpectsCallback && called) {\n                throw exception;\n            }\n            return done(exception);\n        }\n        if (!fnExpectsCallback) {\n            if (result instanceof Promise) {\n                result.then(then, done);\n            } else if (result instanceof Error) {\n                done(result);\n            } else {\n                then(result);\n            }\n        }\n    }\n    /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */ function done(error, ...output) {\n        if (!called) {\n            called = true;\n            callback(error, ...output);\n        }\n    }\n    /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */ function then(value) {\n        done(null, value);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdHJvdWdoQDIuMS4wL25vZGVfbW9kdWxlcy90cm91Z2gvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBRUQ7Ozs7Q0FJQyxHQUNNLFNBQVNBO0lBQ2QsOEJBQThCLEdBQzlCLE1BQU1DLE1BQU0sRUFBRTtJQUNkLHFCQUFxQixHQUNyQixNQUFNQyxXQUFXO1FBQUNDO1FBQUtDO0lBQUc7SUFFMUIsT0FBT0Y7SUFFUCxnQkFBZ0IsR0FDaEIsU0FBU0MsSUFBSSxHQUFHRSxNQUFNO1FBQ3BCLElBQUlDLGtCQUFrQixDQUFDO1FBQ3ZCLHFCQUFxQixHQUNyQixNQUFNQyxXQUFXRixPQUFPRyxHQUFHO1FBRTNCLElBQUksT0FBT0QsYUFBYSxZQUFZO1lBQ2xDLE1BQU0sSUFBSUUsVUFBVSw2Q0FBNkNGO1FBQ25FO1FBRUFHLEtBQUssU0FBU0w7UUFFZDs7Ozs7S0FLQyxHQUNELFNBQVNLLEtBQUtDLEtBQUssRUFBRSxHQUFHQyxNQUFNO1lBQzVCLE1BQU1DLEtBQUtaLEdBQUcsQ0FBQyxFQUFFSyxnQkFBZ0I7WUFDakMsSUFBSVEsUUFBUSxDQUFDO1lBRWIsSUFBSUgsT0FBTztnQkFDVEosU0FBU0k7Z0JBQ1Q7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxNQUFPLEVBQUVHLFFBQVFULE9BQU9VLE1BQU0sQ0FBRTtnQkFDOUIsSUFBSUgsTUFBTSxDQUFDRSxNQUFNLEtBQUssUUFBUUYsTUFBTSxDQUFDRSxNQUFNLEtBQUtFLFdBQVc7b0JBQ3pESixNQUFNLENBQUNFLE1BQU0sR0FBR1QsTUFBTSxDQUFDUyxNQUFNO2dCQUMvQjtZQUNGO1lBRUEscURBQXFEO1lBQ3JEVCxTQUFTTztZQUVULGdCQUFnQjtZQUNoQixJQUFJQyxJQUFJO2dCQUNOSSxLQUFLSixJQUFJSCxTQUFTRTtZQUNwQixPQUFPO2dCQUNMTCxTQUFTLFNBQVNLO1lBQ3BCO1FBQ0Y7SUFDRjtJQUVBLGdCQUFnQixHQUNoQixTQUFTUixJQUFJYyxVQUFVO1FBQ3JCLElBQUksT0FBT0EsZUFBZSxZQUFZO1lBQ3BDLE1BQU0sSUFBSVQsVUFDUixpREFBaURTO1FBRXJEO1FBRUFqQixJQUFJa0IsSUFBSSxDQUFDRDtRQUNULE9BQU9oQjtJQUNUO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ00sU0FBU2UsS0FBS0csVUFBVSxFQUFFYixRQUFRO0lBQ3ZDLG9CQUFvQixHQUNwQixJQUFJYztJQUVKLE9BQU9DO0lBRVA7Ozs7O0dBS0MsR0FDRCxTQUFTQSxRQUFRLEdBQUdDLFVBQVU7UUFDNUIsTUFBTUMsb0JBQW9CSixXQUFXTCxNQUFNLEdBQUdRLFdBQVdSLE1BQU07UUFDL0QsZ0JBQWdCLEdBQ2hCLElBQUlVO1FBRUosSUFBSUQsbUJBQW1CO1lBQ3JCRCxXQUFXSixJQUFJLENBQUNPO1FBQ2xCO1FBRUEsSUFBSTtZQUNGRCxTQUFTTCxXQUFXTyxLQUFLLENBQUMsSUFBSSxFQUFFSjtRQUNsQyxFQUFFLE9BQU9aLE9BQU87WUFDZCxNQUFNaUIsWUFBWSxrQkFBa0IsR0FBSWpCO1lBRXhDLGtDQUFrQztZQUNsQyx5RUFBeUU7WUFDekUsa0JBQWtCO1lBQ2xCLDJEQUEyRDtZQUMzRCxJQUFJYSxxQkFBcUJILFFBQVE7Z0JBQy9CLE1BQU1PO1lBQ1I7WUFFQSxPQUFPRixLQUFLRTtRQUNkO1FBRUEsSUFBSSxDQUFDSixtQkFBbUI7WUFDdEIsSUFBSUMsa0JBQWtCSSxTQUFTO2dCQUM3QkosT0FBT0ssSUFBSSxDQUFDQSxNQUFNSjtZQUNwQixPQUFPLElBQUlELGtCQUFrQk0sT0FBTztnQkFDbENMLEtBQUtEO1lBQ1AsT0FBTztnQkFDTEssS0FBS0w7WUFDUDtRQUNGO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRCxTQUFTQyxLQUFLZixLQUFLLEVBQUUsR0FBR0MsTUFBTTtRQUM1QixJQUFJLENBQUNTLFFBQVE7WUFDWEEsU0FBUztZQUNUZCxTQUFTSSxVQUFVQztRQUNyQjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELFNBQVNrQixLQUFLRSxLQUFLO1FBQ2pCTixLQUFLLE1BQU1NO0lBQ2I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RheG9ub215Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3Ryb3VnaEAyLjEuMC9ub2RlX21vZHVsZXMvdHJvdWdoL2luZGV4LmpzP2M4NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7KGVycm9yPzogRXJyb3J8bnVsbHx1bmRlZmluZWQsIC4uLm91dHB1dDogQXJyYXk8YW55PikgPT4gdm9pZH0gQ2FsbGJhY2tcbiAqIEB0eXBlZGVmIHsoLi4uaW5wdXQ6IEFycmF5PGFueT4pID0+IGFueX0gTWlkZGxld2FyZVxuICpcbiAqIEB0eXBlZGVmIHsoLi4uaW5wdXQ6IEFycmF5PGFueT4pID0+IHZvaWR9IFJ1blxuICogICBDYWxsIGFsbCBtaWRkbGV3YXJlLlxuICogQHR5cGVkZWYgeyhmbjogTWlkZGxld2FyZSkgPT4gUGlwZWxpbmV9IFVzZVxuICogICBBZGQgYGZuYCAobWlkZGxld2FyZSkgdG8gdGhlIGxpc3QuXG4gKiBAdHlwZWRlZiB7e3J1bjogUnVuLCB1c2U6IFVzZX19IFBpcGVsaW5lXG4gKiAgIE1pZGRsZXdhcmUuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbmV3IG1pZGRsZXdhcmUuXG4gKlxuICogQHJldHVybnMge1BpcGVsaW5lfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJvdWdoKCkge1xuICAvKiogQHR5cGUge0FycmF5PE1pZGRsZXdhcmU+fSAqL1xuICBjb25zdCBmbnMgPSBbXVxuICAvKiogQHR5cGUge1BpcGVsaW5lfSAqL1xuICBjb25zdCBwaXBlbGluZSA9IHtydW4sIHVzZX1cblxuICByZXR1cm4gcGlwZWxpbmVcblxuICAvKiogQHR5cGUge1J1bn0gKi9cbiAgZnVuY3Rpb24gcnVuKC4uLnZhbHVlcykge1xuICAgIGxldCBtaWRkbGV3YXJlSW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2t9ICovXG4gICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZXMucG9wKClcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGZ1bmN0aW9uIGFzIGxhc3QgYXJndW1lbnQsIG5vdCAnICsgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgbmV4dChudWxsLCAuLi52YWx1ZXMpXG5cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIG5leHQgYGZuYCwgb3Igd2XigJlyZSBkb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcnxudWxsfHVuZGVmaW5lZH0gZXJyb3JcbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IG91dHB1dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5leHQoZXJyb3IsIC4uLm91dHB1dCkge1xuICAgICAgY29uc3QgZm4gPSBmbnNbKyttaWRkbGV3YXJlSW5kZXhdXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IG5vbi1udWxsaXNoIGlucHV0IGludG8gdmFsdWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvdXRwdXRbaW5kZXhdID09PSBudWxsIHx8IG91dHB1dFtpbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG91dHB1dFtpbmRleF0gPSB2YWx1ZXNbaW5kZXhdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2F2ZSB0aGUgbmV3bHkgY3JlYXRlZCBgb3V0cHV0YCBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgIHZhbHVlcyA9IG91dHB1dFxuXG4gICAgICAvLyBOZXh0IG9yIGRvbmUuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgd3JhcChmbiwgbmV4dCkoLi4ub3V0cHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgLi4ub3V0cHV0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7VXNlfSAqL1xuICBmdW5jdGlvbiB1c2UobWlkZGVsd2FyZSkge1xuICAgIGlmICh0eXBlb2YgbWlkZGVsd2FyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIGBtaWRkZWx3YXJlYCB0byBiZSBhIGZ1bmN0aW9uLCBub3QgJyArIG1pZGRlbHdhcmVcbiAgICAgIClcbiAgICB9XG5cbiAgICBmbnMucHVzaChtaWRkZWx3YXJlKVxuICAgIHJldHVybiBwaXBlbGluZVxuICB9XG59XG5cbi8qKlxuICogV3JhcCBgbWlkZGxld2FyZWAuXG4gKiBDYW4gYmUgc3luYyBvciBhc3luYzsgcmV0dXJuIGEgcHJvbWlzZSwgcmVjZWl2ZSBhIGNhbGxiYWNrLCBvciByZXR1cm4gbmV3XG4gKiB2YWx1ZXMgYW5kIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge01pZGRsZXdhcmV9IG1pZGRsZXdhcmVcbiAqIEBwYXJhbSB7Q2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKG1pZGRsZXdhcmUsIGNhbGxiYWNrKSB7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgbGV0IGNhbGxlZFxuXG4gIHJldHVybiB3cmFwcGVkXG5cbiAgLyoqXG4gICAqIENhbGwgYG1pZGRsZXdhcmVgLlxuICAgKiBAdGhpcyB7YW55fVxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVkKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBmbkV4cGVjdHNDYWxsYmFjayA9IG1pZGRsZXdhcmUubGVuZ3RoID4gcGFyYW1ldGVycy5sZW5ndGhcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICBsZXQgcmVzdWx0XG5cbiAgICBpZiAoZm5FeHBlY3RzQ2FsbGJhY2spIHtcbiAgICAgIHBhcmFtZXRlcnMucHVzaChkb25lKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBtaWRkbGV3YXJlLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGV4Y2VwdGlvbiA9IC8qKiBAdHlwZSB7RXJyb3J9ICovIChlcnJvcilcblxuICAgICAgLy8gV2VsbCwgdGhpcyBpcyBxdWl0ZSB0aGUgcGlja2xlLlxuICAgICAgLy8gYG1pZGRsZXdhcmVgIHJlY2VpdmVkIGEgY2FsbGJhY2sgYW5kIGNhbGxlZCBpdCBzeW5jaHJvbm91c2x5LCBidXQgdGhhdFxuICAgICAgLy8gdGhyZXcgYW4gZXJyb3IuXG4gICAgICAvLyBUaGUgb25seSB0aGluZyBsZWZ0IHRvIGRvIGlzIHRvIHRocm93IHRoZSB0aGluZyBpbnN0ZWFkLlxuICAgICAgaWYgKGZuRXhwZWN0c0NhbGxiYWNrICYmIGNhbGxlZCkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb25cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvbmUoZXhjZXB0aW9uKVxuICAgIH1cblxuICAgIGlmICghZm5FeHBlY3RzQ2FsbGJhY2spIHtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKHRoZW4sIGRvbmUpXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGRvbmUocmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhlbihyZXN1bHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGNhbGxiYWNrYCwgb25seSBvbmNlLlxuICAgKiBAdHlwZSB7Q2FsbGJhY2t9XG4gICAqL1xuICBmdW5jdGlvbiBkb25lKGVycm9yLCAuLi5vdXRwdXQpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgY2FsbGJhY2soZXJyb3IsIC4uLm91dHB1dClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBgZG9uZWAgd2l0aCBvbmUgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG4gICAqL1xuICBmdW5jdGlvbiB0aGVuKHZhbHVlKSB7XG4gICAgZG9uZShudWxsLCB2YWx1ZSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbInRyb3VnaCIsImZucyIsInBpcGVsaW5lIiwicnVuIiwidXNlIiwidmFsdWVzIiwibWlkZGxld2FyZUluZGV4IiwiY2FsbGJhY2siLCJwb3AiLCJUeXBlRXJyb3IiLCJuZXh0IiwiZXJyb3IiLCJvdXRwdXQiLCJmbiIsImluZGV4IiwibGVuZ3RoIiwidW5kZWZpbmVkIiwid3JhcCIsIm1pZGRlbHdhcmUiLCJwdXNoIiwibWlkZGxld2FyZSIsImNhbGxlZCIsIndyYXBwZWQiLCJwYXJhbWV0ZXJzIiwiZm5FeHBlY3RzQ2FsbGJhY2siLCJyZXN1bHQiLCJkb25lIiwiYXBwbHkiLCJleGNlcHRpb24iLCJQcm9taXNlIiwidGhlbiIsIkVycm9yIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/trough@2.1.0/node_modules/trough/index.js\n");

/***/ })

};
;