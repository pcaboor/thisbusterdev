"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-from-markdown@1.3.0";
exports.ids = ["vendor-chunks/mdast-util-from-markdown@1.3.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/mdast-util-from-markdown@1.3.0/node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/mdast-util-from-markdown@1.3.0/node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(rsc)/./node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mdast-util-to-string */ \"(rsc)/./node_modules/.pnpm/mdast-util-to-string@3.2.0/node_modules/mdast-util-to-string/lib/index.js\");\n/* harmony import */ var micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark/lib/parse.js */ \"(rsc)/./node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/dev/lib/parse.js\");\n/* harmony import */ var micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark/lib/preprocess.js */ \"(rsc)/./node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/dev/lib/preprocess.js\");\n/* harmony import */ var micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark/lib/postprocess.js */ \"(rsc)/./node_modules/.pnpm/micromark@3.1.0/node_modules/micromark/dev/lib/postprocess.js\");\n/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ \"(rsc)/./node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.0.0/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\");\n/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-decode-string */ \"(rsc)/./node_modules/.pnpm/micromark-util-decode-string@1.0.2/node_modules/micromark-util-decode-string/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(rsc)/./node_modules/.pnpm/micromark-util-normalize-identifier@1.0.0/node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/codes.js\");\n/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/constants.js\");\n/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/types.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! decode-named-character-reference */ \"(rsc)/./node_modules/.pnpm/decode-named-character-reference@1.0.2/node_modules/decode-named-character-reference/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-stringify-position */ \"(rsc)/./node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/lib/index.js\");\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ // To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */ const fromMarkdown = /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */ /**\n     * @param {Value} value\n     * @param {Encoding | Options | null | undefined} [encoding]\n     * @param {Options | null | undefined} [options]\n     * @returns {Root}\n     */ function(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return compiler(options)((0,micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_1__.postprocess)(// @ts-expect-error: micromark types need to accept `null`.\n    (0,micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__.parse)(options).document().write((0,micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__.preprocess)()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config,\n            enter,\n            exit,\n            buffer,\n            resume,\n            setData,\n            getData\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length){\n            // We preprocess lists to add `listItem` tokens, and to infer whether\n            // items the list itself are spread out.\n            if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered || events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered) {\n                if (events[index][0] === \"enter\") {\n                    listStack.push(index);\n                } else {\n                    const tail = listStack.pop();\n                    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tail === \"number\", \"expected list ot be open\");\n                    index = prepareList(events, tail, index);\n                }\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if (own.call(handler, events[index][1].type)) {\n                handler[events[index][1].type].call(Object.assign({\n                    sliceSerialize: events[index][2].sliceSerialize\n                }, context), events[index][1]);\n            }\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length){\n            tree = config.transforms[index](tree) || tree;\n        }\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuote) {\n                if (event[0] === \"enter\") {\n                    containerBalance++;\n                } else {\n                    containerBalance--;\n                }\n                atMarker = undefined;\n            } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank) {\n                if (event[0] === \"enter\") {\n                    if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                        firstBlankLineIndex = index;\n                    }\n                    atMarker = undefined;\n                }\n            } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemValue || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemMarker || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace) {\n            // Empty.\n            } else {\n                atMarker = undefined;\n            }\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered || event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered)) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank) {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEndingBlank;\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding;\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefix || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefixWhitespace || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuoteMarker || tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemIndent) {\n                        // Empty\n                        } else {\n                            break;\n                        }\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n                        // @ts-expect-error Patched.\n                        listItem._spread = true;\n                    }\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix) {\n                    listItem = {\n                        type: \"listItem\",\n                        // @ts-expect-error Patched\n                        _spread: false,\n                        start: Object.assign({}, event[1].start)\n                    };\n                    // @ts-expect-error: `listItem` is most definitely defined, TS...\n                    events.splice(index, 0, [\n                        \"enter\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        // @ts-expect-error Patched.\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */ function setData(key, value) {\n        data[key] = value;\n    }\n    /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */ function getData(key) {\n        return data[key];\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {void}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(parent, \"expected `parent`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in parent, \"expected `parent`\");\n        // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n        parent.children.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        // @ts-expect-error: `end` will be patched later.\n        node.position = {\n            start: point(token.start)\n        };\n        return node;\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected `node`\");\n        const open = this.tokenStack.pop();\n        if (!open) {\n            throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n                start: token.start,\n                end: token.end\n            }) + \"): it’s not open\");\n        } else if (open[0].type !== token.type) {\n            if (onExitError) {\n                onExitError.call(this, token, open[0]);\n            } else {\n                const handler = open[1] || defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type !== \"fragment\", \"unexpected fragment `exit`ed\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position, \"expected `position` to be defined\");\n        node.position.end = point(token.end);\n        return node;\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        setData(\"expectingFirstListItemValue\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (getData(\"expectingFirstListItemValue\")) {\n            const ancestor = this.stack[this.stack.length - 2];\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, \"expected nodes on stack\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === \"list\", \"expected list on stack\");\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal);\n            setData(\"expectingFirstListItemValue\");\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (getData(\"flowCodeInside\")) return;\n        this.buffer();\n        setData(\"flowCodeInside\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        setData(\"flowCodeInside\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.label = label;\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, \"expected `depth` between `1` and `6`\");\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        setData(\"setextHeadingSlurpLineEnding\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        node.depth = this.sliceSerialize(token).charCodeAt(0) === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_9__.codes.equalsTo ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        setData(\"setextHeadingSlurpLineEnding\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in node, \"expected parent on stack\");\n        let tail = node.children[node.children.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            // @ts-expect-error: we’ll add `end` later.\n            tail.position = {\n                start: point(token.start)\n            };\n            // @ts-expect-error: Assume `parent` accepts `text`.\n            node.children.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, \"expected a `node` to be on the stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"value\" in tail, \"expected a `literal` to be on the stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected `node` to have an open position\");\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(context, \"expected `node`\");\n        // If we’re at a hard break, include the line ending in there.\n        if (getData(\"atHardBreak\")) {\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"children\" in context, \"expected `parent`\");\n            const tail = context.children[context.children.length - 1];\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected tail to have a starting position\");\n            tail.position.end = point(token.end);\n            setData(\"atHardBreak\");\n            return;\n        }\n        if (!getData(\"setextHeadingSlurpLineEnding\") && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        setData(\"atHardBreak\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"inlineCode\", \"expected inline code on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\", \"expected image on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (getData(\"inReference\")) {\n            /** @type {ReferenceType} */ const referenceType = getData(\"referenceType\") || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        setData(\"referenceType\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, \"expected ancestor on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === \"image\" || ancestor.type === \"link\", \"expected image or link on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment.type === \"fragment\", \"expected fragment on stack\");\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        // Assume a reference.\n        setData(\"inReference\", true);\n        if (node.type === \"link\") {\n            /** @type {Array<StaticPhrasingContent>} */ // @ts-expect-error: Assume static phrasing content.\n            const children = fragment.children;\n            node.children = children;\n        } else {\n            node.alt = value;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        setData(\"inReference\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        setData(\"referenceType\", \"collapsed\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image reference or link reference on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        setData(\"referenceType\", \"full\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(token.type === \"characterReferenceMarkerNumeric\" || token.type === \"characterReferenceMarkerHexadecimal\");\n        setData(\"characterReferenceType\", token.type);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = getData(\"characterReferenceType\");\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNumericCharacterReference)(data, type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerNumeric ? micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseHexadecimal);\n            setData(\"characterReferenceType\");\n        } else {\n            const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__.decodeNamedCharacterReference)(data);\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(result !== false, \"expected reference to decode\");\n            value = result;\n        }\n        const tail = this.stack.pop();\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, \"expected `node`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, \"expected `node.position`\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(\"value\" in tail, \"expected `node.value`\");\n        tail.value += value;\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, \"expected node on stack\");\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        // @ts-expect-error `depth` will be set later.\n        return {\n            type: \"heading\",\n            depth: undefined,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {HTML} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            // @ts-expect-error Patched.\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            // @ts-expect-error Patched.\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */ function configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) {\n            configure(combined, value);\n        } else {\n            extension(combined, value);\n        }\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */ function extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension){\n        if (own.call(extension, key)) {\n            if (key === \"canContainEols\") {\n                const right = extension[key];\n                if (right) {\n                    combined[key].push(...right);\n                }\n            } else if (key === \"transforms\") {\n                const right = extension[key];\n                if (right) {\n                    combined[key].push(...right);\n                }\n            } else if (key === \"enter\" || key === \"exit\") {\n                const right = extension[key];\n                if (right) {\n                    Object.assign(combined[key], right);\n                }\n            }\n        }\n    }\n}\n/** @type {OnEnterError} */ function defaultOnError(left, right) {\n    if (left) {\n        throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: left.start,\n            end: left.end\n        }) + \"): a different token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is open\");\n    } else {\n        throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is still open\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duQDEuMy4wL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb20tbWFya2Rvd24vZGV2L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1DQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0NDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0NDLEdBRUQsaURBQWlEO0FBQ2pELDZEQUE2RDtBQUM3RCwyQ0FBMkM7QUFFSjtBQUNNO0FBQ0Q7QUFDVTtBQUNFO0FBQ3lDO0FBQ3hDO0FBQ2M7QUFDbkI7QUFDUTtBQUNSO0FBQzBCO0FBQ2Y7QUFFL0QsTUFBTWMsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFN0I7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUMsZUFDWDs7Ozs7R0FLQyxHQUVDOzs7OztLQUtDLEdBQ0QsU0FBVUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDaEMsSUFBSSxPQUFPRCxhQUFhLFVBQVU7UUFDaENDLFVBQVVEO1FBQ1ZBLFdBQVdFO0lBQ2I7SUFFQSxPQUFPQyxTQUFTRixTQUNkZCx5RUFBV0EsQ0FDVCwyREFBMkQ7SUFDM0RGLDZEQUFLQSxDQUFDZ0IsU0FBU0csUUFBUSxHQUFHQyxLQUFLLENBQUNuQix1RUFBVUEsR0FBR2EsT0FBT0MsVUFBVTtBQUdwRSxFQUNEO0FBRUg7Ozs7Q0FJQyxHQUNELFNBQVNHLFNBQVNGLE9BQU87SUFDdkIsbUJBQW1CLEdBQ25CLE1BQU1LLFNBQVM7UUFDYkMsWUFBWSxFQUFFO1FBQ2RDLGdCQUFnQjtZQUFDO1lBQVk7WUFBWTtZQUFXO1lBQWE7U0FBUztRQUMxRUMsT0FBTztZQUNMQyxV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QUFLOEQsTUFBTTlELEdBQUc7UUFBQSxLQUNyRDtJQUVOO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YXhvbm9teS8uL25vZGVfbW9kdWxlcy8ucG5wbS9tZGFzdC11dGlsLWZyb20tbWFya2Rvd25AMS4zLjAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bi9kZXYvbGliL2luZGV4LmpzP2ExN2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkVuY29kaW5nfSBFbmNvZGluZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FdmVudH0gRXZlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUGFyc2VPcHRpb25zfSBQYXJzZU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VuaXplQ29udGV4dH0gVG9rZW5pemVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlZhbHVlfSBWYWx1ZVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUGFyZW50fSBVbmlzdFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gUG9pbnRcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBocmFzaW5nQ29udGVudH0gUGhyYXNpbmdDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlN0YXRpY1BocmFzaW5nQ29udGVudH0gU3RhdGljUGhyYXNpbmdDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkNvbnRlbnR9IENvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQnJlYWt9IEJyZWFrXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkJsb2NrcXVvdGV9IEJsb2NrcXVvdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29kZX0gQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5EZWZpbml0aW9ufSBEZWZpbml0aW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkVtcGhhc2lzfSBFbXBoYXNpc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5IZWFkaW5nfSBIZWFkaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkhUTUx9IEhUTUxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW1hZ2V9IEltYWdlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkltYWdlUmVmZXJlbmNlfSBJbWFnZVJlZmVyZW5jZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbmxpbmVDb2RlfSBJbmxpbmVDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpbmt9IExpbmtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlua1JlZmVyZW5jZX0gTGlua1JlZmVyZW5jZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXN0fSBMaXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3RJdGVtfSBMaXN0SXRlbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJhZ3JhcGh9IFBhcmFncmFwaFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Sb290fSBSb290XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlN0cm9uZ30gU3Ryb25nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRleHR9IFRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGhlbWF0aWNCcmVha30gVGhlbWF0aWNCcmVha1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5SZWZlcmVuY2VUeXBlfSBSZWZlcmVuY2VUeXBlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9pbmRleC5qcycpLkNvbXBpbGVEYXRhfSBDb21waWxlRGF0YVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1Jvb3QgfCBDb250ZW50fSBOb2RlXG4gKiBAdHlwZWRlZiB7RXh0cmFjdDxOb2RlLCBVbmlzdFBhcmVudD59IFBhcmVudFxuICpcbiAqIEB0eXBlZGVmIHtPbWl0PFVuaXN0UGFyZW50LCAndHlwZScgfCAnY2hpbGRyZW4nPiAmIHt0eXBlOiAnZnJhZ21lbnQnLCBjaGlsZHJlbjogQXJyYXk8UGhyYXNpbmdDb250ZW50Pn19IEZyYWdtZW50XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgVHJhbnNmb3JtXG4gKiAgIEV4dHJhIHRyYW5zZm9ybSwgdG8gY2hhbmdlIHRoZSBBU1QgYWZ0ZXJ3YXJkcy5cbiAqIEBwYXJhbSB7Um9vdH0gdHJlZVxuICogICBUcmVlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtSb290IHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWR9XG4gKiAgIE5ldyB0cmVlIG9yIG5vdGhpbmcgKGluIHdoaWNoIGNhc2UgdGhlIGN1cnJlbnQgdHJlZSBpcyB1c2VkKS5cbiAqXG4gKiBAY2FsbGJhY2sgSGFuZGxlXG4gKiAgIEhhbmRsZSBhIHRva2VuLlxuICogQHBhcmFtIHtDb21waWxlQ29udGV4dH0gdGhpc1xuICogICBDb250ZXh0LlxuICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAqICAgQ3VycmVudCB0b2tlbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBIYW5kbGU+fSBIYW5kbGVzXG4gKiAgIFRva2VuIHR5cGVzIG1hcHBpbmcgdG8gaGFuZGxlc1xuICpcbiAqIEBjYWxsYmFjayBPbkVudGVyRXJyb3JcbiAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBgcmlnaHRgIHRva2VuIGlzIG9wZW4sIGJ1dCBpdCBpcyBjbG9zZWQgKGJ5IHRoZVxuICogICBgbGVmdGAgdG9rZW4pIG9yIGJlY2F1c2Ugd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59IHRoaXNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7VG9rZW4gfCB1bmRlZmluZWR9IGxlZnRcbiAqICAgTGVmdCB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHJpZ2h0XG4gKiAgIFJpZ2h0IHRva2VuLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiAgIE5vdGhpbmcuXG4gKlxuICogQGNhbGxiYWNrIE9uRXhpdEVycm9yXG4gKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgYHJpZ2h0YCB0b2tlbiBpcyBvcGVuIGJ1dCBpdCBpcyBjbG9zZWQgYnlcbiAqICAgZXhpdGluZyB0aGUgYGxlZnRgIHRva2VuLlxuICogQHBhcmFtIHtPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPn0gdGhpc1xuICogICBDb250ZXh0LlxuICogQHBhcmFtIHtUb2tlbn0gbGVmdFxuICogICBMZWZ0IHRva2VuLlxuICogQHBhcmFtIHtUb2tlbn0gcmlnaHRcbiAqICAgUmlnaHQgdG9rZW4uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAdHlwZWRlZiB7W1Rva2VuLCBPbkVudGVyRXJyb3IgfCB1bmRlZmluZWRdfSBUb2tlblR1cGxlXG4gKiAgIE9wZW4gdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRoIGFuIG9wdGlvbmFsIGVycm9yIGhhbmRsZXIgZm9yIHdoZW5cbiAqICAgdGhhdCB0b2tlbiBpc27igJl0IGNsb3NlZCBwcm9wZXJseS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIENvbmZpZ1xuICogICBDb25maWd1cmF0aW9uLlxuICpcbiAqICAgV2UgaGF2ZSBvdXIgZGVmYXVsdHMsIGJ1dCBleHRlbnNpb25zIHdpbGwgYWRkIG1vcmUuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGNhbkNvbnRhaW5Fb2xzXG4gKiAgIFRva2VuIHR5cGVzIHdoZXJlIGxpbmUgZW5kaW5ncyBhcmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SGFuZGxlc30gZW50ZXJcbiAqICAgT3BlbmluZyBoYW5kbGVzLlxuICogQHByb3BlcnR5IHtIYW5kbGVzfSBleGl0XG4gKiAgIENsb3NpbmcgaGFuZGxlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8VHJhbnNmb3JtPn0gdHJhbnNmb3Jtc1xuICogICBUcmVlIHRyYW5zZm9ybXMuXG4gKlxuICogQHR5cGVkZWYge1BhcnRpYWw8Q29uZmlnPn0gRXh0ZW5zaW9uXG4gKiAgIENoYW5nZSBob3cgbWFya2Rvd24gdG9rZW5zIGZyb20gbWljcm9tYXJrIGFyZSB0dXJuZWQgaW50byBtZGFzdC5cbiAqXG4gKiBAdHlwZWRlZiBDb21waWxlQ29udGV4dFxuICogICBtZGFzdCBjb21waWxlciBjb250ZXh0LlxuICogQHByb3BlcnR5IHtBcnJheTxOb2RlIHwgRnJhZ21lbnQ+fSBzdGFja1xuICogICBTdGFjayBvZiBub2Rlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8VG9rZW5UdXBsZT59IHRva2VuU3RhY2tcbiAqICAgU3RhY2sgb2YgdG9rZW5zLlxuICogQHByb3BlcnR5IHs8S2V5IGV4dGVuZHMga2V5b2YgQ29tcGlsZURhdGE+KGtleTogS2V5KSA9PiBDb21waWxlRGF0YVtLZXldfSBnZXREYXRhXG4gKiAgIEdldCBkYXRhIGZyb20gdGhlIGtleS92YWx1ZSBzdG9yZS5cbiAqIEBwcm9wZXJ0eSB7PEtleSBleHRlbmRzIGtleW9mIENvbXBpbGVEYXRhPihrZXk6IEtleSwgdmFsdWU/OiBDb21waWxlRGF0YVtLZXldKSA9PiB2b2lkfSBzZXREYXRhXG4gKiAgIFNldCBkYXRhIGludG8gdGhlIGtleS92YWx1ZSBzdG9yZS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiB2b2lkfSBidWZmZXJcbiAqICAgQ2FwdHVyZSBzb21lIG9mIHRoZSBvdXRwdXQgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiBzdHJpbmd9IHJlc3VtZVxuICogICBTdG9wIGNhcHR1cmluZyBhbmQgYWNjZXNzIHRoZSBvdXRwdXQgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7PEtpbmQgZXh0ZW5kcyBOb2RlPih0aGlzOiBDb21waWxlQ29udGV4dCwgbm9kZTogS2luZCwgdG9rZW46IFRva2VuLCBvbkVycm9yPzogT25FbnRlckVycm9yKSA9PiBLaW5kfSBlbnRlclxuICogICBFbnRlciBhIHRva2VuLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQsIHRva2VuOiBUb2tlbiwgb25FcnJvcj86IE9uRXhpdEVycm9yKSA9PiBOb2RlfSBleGl0XG4gKiAgIEV4aXQgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVDb250ZXh0WydzbGljZVNlcmlhbGl6ZSddfSBzbGljZVNlcmlhbGl6ZVxuICogICBHZXQgdGhlIHN0cmluZyB2YWx1ZSBvZiBhIHRva2VuLlxuICogQHByb3BlcnR5IHtDb25maWd9IGNvbmZpZ1xuICogICBDb25maWd1cmF0aW9uLlxuICpcbiAqIEB0eXBlZGVmIEZyb21NYXJrZG93bk9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgaG93IHRvIGJ1aWxkIG1kYXN0LlxuICogQHByb3BlcnR5IHtBcnJheTxFeHRlbnNpb24gfCBBcnJheTxFeHRlbnNpb24+PiB8IG51bGwgfCB1bmRlZmluZWR9IFttZGFzdEV4dGVuc2lvbnNdXG4gKiAgIEV4dGVuc2lvbnMgZm9yIHRoaXMgdXRpbGl0eSB0byBjaGFuZ2UgaG93IHRva2VucyBhcmUgdHVybmVkIGludG8gYSB0cmVlLlxuICpcbiAqIEB0eXBlZGVmIHtQYXJzZU9wdGlvbnMgJiBGcm9tTWFya2Rvd25PcHRpb25zfSBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKi9cblxuLy8gVG8gZG86IG1pY3JvbWFyazogY3JlYXRlIGEgcmVnaXN0cnkgb2YgdG9rZW5zP1xuLy8gVG8gZG86IG5leHQgbWFqb3I6IGRvbuKAmXQgcmV0dXJuIGdpdmVuIGBOb2RlYCBmcm9tIGBlbnRlcmAuXG4vLyBUbyBkbzogbmV4dCBtYWpvcjogcmVtb3ZlIHNldHRlci9nZXR0ZXIuXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICd1dnUvYXNzZXJ0J1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnbWRhc3QtdXRpbC10by1zdHJpbmcnXG5pbXBvcnQge3BhcnNlfSBmcm9tICdtaWNyb21hcmsvbGliL3BhcnNlLmpzJ1xuaW1wb3J0IHtwcmVwcm9jZXNzfSBmcm9tICdtaWNyb21hcmsvbGliL3ByZXByb2Nlc3MuanMnXG5pbXBvcnQge3Bvc3Rwcm9jZXNzfSBmcm9tICdtaWNyb21hcmsvbGliL3Bvc3Rwcm9jZXNzLmpzJ1xuaW1wb3J0IHtkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtkZWNvZGVTdHJpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWRlY29kZS1zdHJpbmcnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtjb2Rlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sL2NvZGVzLmpzJ1xuaW1wb3J0IHtjb25zdGFudHN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbC9jb25zdGFudHMuanMnXG5pbXBvcnQge3R5cGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wvdHlwZXMuanMnXG5pbXBvcnQge2RlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdkZWNvZGUtbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7c3RyaW5naWZ5UG9zaXRpb259IGZyb20gJ3VuaXN0LXV0aWwtc3RyaW5naWZ5LXBvc2l0aW9uJ1xuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogICBNYXJrZG93biB0byBwYXJzZS5cbiAqIEBwYXJhbSBlbmNvZGluZ1xuICogICBDaGFyYWN0ZXIgZW5jb2RpbmcgZm9yIHdoZW4gYHZhbHVlYCBpcyBgQnVmZmVyYC5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJuc1xuICogICBtZGFzdCB0cmVlLlxuICovXG5leHBvcnQgY29uc3QgZnJvbU1hcmtkb3duID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKCh2YWx1ZTogVmFsdWUsIGVuY29kaW5nOiBFbmNvZGluZywgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBSb290KSAmXG4gICAqICAgKCh2YWx1ZTogVmFsdWUsIG9wdGlvbnM/OiBPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gUm9vdClcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RW5jb2RpbmcgfCBPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VuY29kaW5nXVxuICAgICAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm5zIHtSb290fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSBlbmNvZGluZ1xuICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcGlsZXIob3B0aW9ucykoXG4gICAgICAgIHBvc3Rwcm9jZXNzKFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG1pY3JvbWFyayB0eXBlcyBuZWVkIHRvIGFjY2VwdCBgbnVsbGAuXG4gICAgICAgICAgcGFyc2Uob3B0aW9ucykuZG9jdW1lbnQoKS53cml0ZShwcmVwcm9jZXNzKCkodmFsdWUsIGVuY29kaW5nLCB0cnVlKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIE5vdGUgdGhpcyBjb21waWxlciBvbmx5IHVuZGVyc3RhbmQgY29tcGxldGUgYnVmZmVyaW5nLCBub3Qgc3RyZWFtaW5nLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICovXG5mdW5jdGlvbiBjb21waWxlcihvcHRpb25zKSB7XG4gIC8qKiBAdHlwZSB7Q29uZmlnfSAqL1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgdHJhbnNmb3JtczogW10sXG4gICAgY2FuQ29udGFpbkVvbHM6IFsnZW1waGFzaXMnLCAnZnJhZ21lbnQnLCAnaGVhZGluZycsICdwYXJhZ3JhcGgnLCAnc3Ryb25nJ10sXG4gICAgZW50ZXI6IHtcbiAgICAgIGF1dG9saW5rOiBvcGVuZXIobGluayksXG4gICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmVudGVyZGF0YSxcbiAgICAgIGF1dG9saW5rRW1haWw6IG9uZW50ZXJkYXRhLFxuICAgICAgYXR4SGVhZGluZzogb3BlbmVyKGhlYWRpbmcpLFxuICAgICAgYmxvY2tRdW90ZTogb3BlbmVyKGJsb2NrUXVvdGUpLFxuICAgICAgY2hhcmFjdGVyRXNjYXBlOiBvbmVudGVyZGF0YSxcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZTogb25lbnRlcmRhdGEsXG4gICAgICBjb2RlRmVuY2VkOiBvcGVuZXIoY29kZUZsb3cpLFxuICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogYnVmZmVyLFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogYnVmZmVyLFxuICAgICAgY29kZUluZGVudGVkOiBvcGVuZXIoY29kZUZsb3csIGJ1ZmZlciksXG4gICAgICBjb2RlVGV4dDogb3BlbmVyKGNvZGVUZXh0LCBidWZmZXIpLFxuICAgICAgY29kZVRleHREYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGRhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgY29kZUZsb3dWYWx1ZTogb25lbnRlcmRhdGEsXG4gICAgICBkZWZpbml0aW9uOiBvcGVuZXIoZGVmaW5pdGlvbiksXG4gICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGRlZmluaXRpb25MYWJlbFN0cmluZzogYnVmZmVyLFxuICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBidWZmZXIsXG4gICAgICBlbXBoYXNpczogb3BlbmVyKGVtcGhhc2lzKSxcbiAgICAgIGhhcmRCcmVha0VzY2FwZTogb3BlbmVyKGhhcmRCcmVhayksXG4gICAgICBoYXJkQnJlYWtUcmFpbGluZzogb3BlbmVyKGhhcmRCcmVhayksXG4gICAgICBodG1sRmxvdzogb3BlbmVyKGh0bWwsIGJ1ZmZlciksXG4gICAgICBodG1sRmxvd0RhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgaHRtbFRleHQ6IG9wZW5lcihodG1sLCBidWZmZXIpLFxuICAgICAgaHRtbFRleHREYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGltYWdlOiBvcGVuZXIoaW1hZ2UpLFxuICAgICAgbGFiZWw6IGJ1ZmZlcixcbiAgICAgIGxpbms6IG9wZW5lcihsaW5rKSxcbiAgICAgIGxpc3RJdGVtOiBvcGVuZXIobGlzdEl0ZW0pLFxuICAgICAgbGlzdEl0ZW1WYWx1ZTogb25lbnRlcmxpc3RpdGVtdmFsdWUsXG4gICAgICBsaXN0T3JkZXJlZDogb3BlbmVyKGxpc3QsIG9uZW50ZXJsaXN0b3JkZXJlZCksXG4gICAgICBsaXN0VW5vcmRlcmVkOiBvcGVuZXIobGlzdCksXG4gICAgICBwYXJhZ3JhcGg6IG9wZW5lcihwYXJhZ3JhcGgpLFxuICAgICAgcmVmZXJlbmNlOiBvbmVudGVycmVmZXJlbmNlLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBidWZmZXIsXG4gICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBidWZmZXIsXG4gICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBidWZmZXIsXG4gICAgICBzZXRleHRIZWFkaW5nOiBvcGVuZXIoaGVhZGluZyksXG4gICAgICBzdHJvbmc6IG9wZW5lcihzdHJvbmcpLFxuICAgICAgdGhlbWF0aWNCcmVhazogb3BlbmVyKHRoZW1hdGljQnJlYWspXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBhdHhIZWFkaW5nOiBjbG9zZXIoKSxcbiAgICAgIGF0eEhlYWRpbmdTZXF1ZW5jZTogb25leGl0YXR4aGVhZGluZ3NlcXVlbmNlLFxuICAgICAgYXV0b2xpbms6IGNsb3NlcigpLFxuICAgICAgYXV0b2xpbmtFbWFpbDogb25leGl0YXV0b2xpbmtlbWFpbCxcbiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IG9uZXhpdGF1dG9saW5rcHJvdG9jb2wsXG4gICAgICBibG9ja1F1b3RlOiBjbG9zZXIoKSxcbiAgICAgIGNoYXJhY3RlckVzY2FwZVZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWw6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWM6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZVZhbHVlOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSxcbiAgICAgIGNvZGVGZW5jZWQ6IGNsb3NlcihvbmV4aXRjb2RlZmVuY2VkKSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZTogb25leGl0Y29kZWZlbmNlZGZlbmNlLFxuICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbyxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IG9uZXhpdGNvZGVmZW5jZWRmZW5jZW1ldGEsXG4gICAgICBjb2RlRmxvd1ZhbHVlOiBvbmV4aXRkYXRhLFxuICAgICAgY29kZUluZGVudGVkOiBjbG9zZXIob25leGl0Y29kZWluZGVudGVkKSxcbiAgICAgIGNvZGVUZXh0OiBjbG9zZXIob25leGl0Y29kZXRleHQpLFxuICAgICAgY29kZVRleHREYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgZGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGRlZmluaXRpb246IGNsb3NlcigpLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcsXG4gICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyxcbiAgICAgIGRlZmluaXRpb25UaXRsZVN0cmluZzogb25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nLFxuICAgICAgZW1waGFzaXM6IGNsb3NlcigpLFxuICAgICAgaGFyZEJyZWFrRXNjYXBlOiBjbG9zZXIob25leGl0aGFyZGJyZWFrKSxcbiAgICAgIGhhcmRCcmVha1RyYWlsaW5nOiBjbG9zZXIob25leGl0aGFyZGJyZWFrKSxcbiAgICAgIGh0bWxGbG93OiBjbG9zZXIob25leGl0aHRtbGZsb3cpLFxuICAgICAgaHRtbEZsb3dEYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgaHRtbFRleHQ6IGNsb3NlcihvbmV4aXRodG1sdGV4dCksXG4gICAgICBodG1sVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBpbWFnZTogY2xvc2VyKG9uZXhpdGltYWdlKSxcbiAgICAgIGxhYmVsOiBvbmV4aXRsYWJlbCxcbiAgICAgIGxhYmVsVGV4dDogb25leGl0bGFiZWx0ZXh0LFxuICAgICAgbGluZUVuZGluZzogb25leGl0bGluZWVuZGluZyxcbiAgICAgIGxpbms6IGNsb3NlcihvbmV4aXRsaW5rKSxcbiAgICAgIGxpc3RJdGVtOiBjbG9zZXIoKSxcbiAgICAgIGxpc3RPcmRlcmVkOiBjbG9zZXIoKSxcbiAgICAgIGxpc3RVbm9yZGVyZWQ6IGNsb3NlcigpLFxuICAgICAgcGFyYWdyYXBoOiBjbG9zZXIoKSxcbiAgICAgIHJlZmVyZW5jZVN0cmluZzogb25leGl0cmVmZXJlbmNlc3RyaW5nLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZyxcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcsXG4gICAgICByZXNvdXJjZTogb25leGl0cmVzb3VyY2UsXG4gICAgICBzZXRleHRIZWFkaW5nOiBjbG9zZXIob25leGl0c2V0ZXh0aGVhZGluZyksXG4gICAgICBzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlOiBvbmV4aXRzZXRleHRoZWFkaW5nbGluZXNlcXVlbmNlLFxuICAgICAgc2V0ZXh0SGVhZGluZ1RleHQ6IG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0LFxuICAgICAgc3Ryb25nOiBjbG9zZXIoKSxcbiAgICAgIHRoZW1hdGljQnJlYWs6IGNsb3NlcigpXG4gICAgfVxuICB9XG5cbiAgY29uZmlndXJlKGNvbmZpZywgKG9wdGlvbnMgfHwge30pLm1kYXN0RXh0ZW5zaW9ucyB8fCBbXSlcblxuICAvKiogQHR5cGUge0NvbXBpbGVEYXRhfSAqL1xuICBjb25zdCBkYXRhID0ge31cblxuICByZXR1cm4gY29tcGlsZVxuXG4gIC8qKlxuICAgKiBUdXJuIG1pY3JvbWFyayBldmVudHMgaW50byBhbiBtZGFzdCB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gICAqICAgRXZlbnRzLlxuICAgKiBAcmV0dXJucyB7Um9vdH1cbiAgICogICBtZGFzdCB0cmVlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGlsZShldmVudHMpIHtcbiAgICAvKiogQHR5cGUge1Jvb3R9ICovXG4gICAgbGV0IHRyZWUgPSB7dHlwZTogJ3Jvb3QnLCBjaGlsZHJlbjogW119XG4gICAgLyoqIEB0eXBlIHtPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPn0gKi9cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc3RhY2s6IFt0cmVlXSxcbiAgICAgIHRva2VuU3RhY2s6IFtdLFxuICAgICAgY29uZmlnLFxuICAgICAgZW50ZXIsXG4gICAgICBleGl0LFxuICAgICAgYnVmZmVyLFxuICAgICAgcmVzdW1lLFxuICAgICAgc2V0RGF0YSxcbiAgICAgIGdldERhdGFcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IGxpc3RTdGFjayA9IFtdXG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgLy8gV2UgcHJlcHJvY2VzcyBsaXN0cyB0byBhZGQgYGxpc3RJdGVtYCB0b2tlbnMsIGFuZCB0byBpbmZlciB3aGV0aGVyXG4gICAgICAvLyBpdGVtcyB0aGUgbGlzdCBpdHNlbGYgYXJlIHNwcmVhZCBvdXQuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQgfHxcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkXG4gICAgICApIHtcbiAgICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBsaXN0U3RhY2sucHVzaChpbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YWlsID0gbGlzdFN0YWNrLnBvcCgpXG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWlsID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGxpc3Qgb3QgYmUgb3BlbicpXG4gICAgICAgICAgaW5kZXggPSBwcmVwYXJlTGlzdChldmVudHMsIHRhaWwsIGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gY29uZmlnW2V2ZW50c1tpbmRleF1bMF1dXG5cbiAgICAgIGlmIChvd24uY2FsbChoYW5kbGVyLCBldmVudHNbaW5kZXhdWzFdLnR5cGUpKSB7XG4gICAgICAgIGhhbmRsZXJbZXZlbnRzW2luZGV4XVsxXS50eXBlXS5jYWxsKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7c2xpY2VTZXJpYWxpemU6IGV2ZW50c1tpbmRleF1bMl0uc2xpY2VTZXJpYWxpemV9LFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICksXG4gICAgICAgICAgZXZlbnRzW2luZGV4XVsxXVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRva2VucyBzdGlsbCBiZWluZyBvcGVuLlxuICAgIGlmIChjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQudG9rZW5TdGFja1tjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0YWlsWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgdW5kZWZpbmVkLCB0YWlsWzBdKVxuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgYHJvb3RgIHBvc2l0aW9uLlxuICAgIHRyZWUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwID8gZXZlbnRzWzBdWzFdLnN0YXJ0IDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKSxcbiAgICAgIGVuZDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdWzFdLmVuZFxuICAgICAgICAgIDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENhbGwgdHJhbnNmb3Jtcy5cbiAgICBpbmRleCA9IC0xXG4gICAgd2hpbGUgKCsraW5kZXggPCBjb25maWcudHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgIHRyZWUgPSBjb25maWcudHJhbnNmb3Jtc1tpbmRleF0odHJlZSkgfHwgdHJlZVxuICAgIH1cblxuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3QoZXZlbnRzLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQgLSAxXG4gICAgbGV0IGNvbnRhaW5lckJhbGFuY2UgPSAtMVxuICAgIGxldCBsaXN0U3ByZWFkID0gZmFsc2VcbiAgICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaXN0SXRlbVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaW5lSW5kZXhcbiAgICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgZmlyc3RCbGFua0xpbmVJbmRleFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgYXRNYXJrZXJcblxuICAgIHdoaWxlICgrK2luZGV4IDw9IGxlbmd0aCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdFVub3JkZXJlZCB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCB8fFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5ibG9ja1F1b3RlXG4gICAgICApIHtcbiAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgY29udGFpbmVyQmFsYW5jZSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyQmFsYW5jZS0tXG4gICAgICAgIH1cblxuICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIGlmIChldmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmspIHtcbiAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGlzdEl0ZW0gJiZcbiAgICAgICAgICAgICFhdE1hcmtlciAmJlxuICAgICAgICAgICAgIWNvbnRhaW5lckJhbGFuY2UgJiZcbiAgICAgICAgICAgICFmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ID0gaW5kZXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lUHJlZml4IHx8XG4gICAgICAgIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtVmFsdWUgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1NYXJrZXIgfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXggfHxcbiAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlXG4gICAgICApIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgICghY29udGFpbmVyQmFsYW5jZSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZW50ZXInICYmXG4gICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXgpIHx8XG4gICAgICAgIChjb250YWluZXJCYWxhbmNlID09PSAtMSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICAoZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdFVub3JkZXJlZCB8fFxuICAgICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbSkge1xuICAgICAgICAgIGxldCB0YWlsSW5kZXggPSBpbmRleFxuICAgICAgICAgIGxpbmVJbmRleCA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgd2hpbGUgKHRhaWxJbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCB0YWlsRXZlbnQgPSBldmVudHNbdGFpbEluZGV4XVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAodGFpbEV2ZW50WzBdID09PSAnZXhpdCcpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAgICAgICAgIGV2ZW50c1tsaW5lSW5kZXhdWzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgICAgICBsaXN0U3ByZWFkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nXG4gICAgICAgICAgICAgIGxpbmVJbmRleCA9IHRhaWxJbmRleFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVQcmVmaXggfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVQcmVmaXggfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5ibG9ja1F1b3RlTWFya2VyIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbUluZGVudFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEVtcHR5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggJiZcbiAgICAgICAgICAgICghbGluZUluZGV4IHx8IGZpcnN0QmxhbmtMaW5lSW5kZXggPCBsaW5lSW5kZXgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoZWQuXG4gICAgICAgICAgICBsaXN0SXRlbS5fc3ByZWFkID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpeCBwb3NpdGlvbi5cbiAgICAgICAgICBsaXN0SXRlbS5lbmQgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBsaW5lSW5kZXggPyBldmVudHNbbGluZUluZGV4XVsxXS5zdGFydCA6IGV2ZW50WzFdLmVuZFxuICAgICAgICAgIClcblxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UobGluZUluZGV4IHx8IGluZGV4LCAwLCBbJ2V4aXQnLCBsaXN0SXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpc3QgaXRlbS5cbiAgICAgICAgaWYgKGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtUHJlZml4KSB7XG4gICAgICAgICAgbGlzdEl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkXG4gICAgICAgICAgICBfc3ByZWFkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudFsxXS5zdGFydClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGxpc3RJdGVtYCBpcyBtb3N0IGRlZmluaXRlbHkgZGVmaW5lZCwgVFMuLi5cbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAwLCBbJ2VudGVyJywgbGlzdEl0ZW0sIGV2ZW50WzJdXSlcbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgbGVuZ3RoKytcbiAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ID0gdW5kZWZpbmVkXG4gICAgICAgICAgYXRNYXJrZXIgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoZWQuXG4gICAgZXZlbnRzW3N0YXJ0XVsxXS5fc3ByZWFkID0gbGlzdFNwcmVhZFxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGF0YS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBDb21waWxlRGF0YX0gS2V5XG4gICAqICAgRmllbGQgdHlwZS5cbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiAgIEtleSBvZiBmaWVsZC5cbiAgICogQHBhcmFtIHtDb21waWxlRGF0YVtLZXldfSBbdmFsdWVdXG4gICAqICAgTmV3IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0RGF0YShrZXksIHZhbHVlKSB7XG4gICAgZGF0YVtrZXldID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBDb21waWxlRGF0YX0gS2V5XG4gICAqICAgRmllbGQgdHlwZS5cbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiAgIEtleSBvZiBmaWVsZC5cbiAgICogQHJldHVybnMge0NvbXBpbGVEYXRhW0tleV19XG4gICAqICAgVmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXREYXRhKGtleSkge1xuICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb3BlbmVyIGhhbmRsZS5cbiAgICpcbiAgICogQHBhcmFtIHsodG9rZW46IFRva2VuKSA9PiBOb2RlfSBjcmVhdGVcbiAgICogICBDcmVhdGUgYSBub2RlLlxuICAgKiBAcGFyYW0ge0hhbmRsZX0gW2FuZF1cbiAgICogICBPcHRpb25hbCBmdW5jdGlvbiB0byBhbHNvIHJ1bi5cbiAgICogQHJldHVybnMge0hhbmRsZX1cbiAgICogICBIYW5kbGUuXG4gICAqL1xuICBmdW5jdGlvbiBvcGVuZXIoY3JlYXRlLCBhbmQpIHtcbiAgICByZXR1cm4gb3BlblxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb3Blbih0b2tlbikge1xuICAgICAgZW50ZXIuY2FsbCh0aGlzLCBjcmVhdGUodG9rZW4pLCB0b2tlbilcbiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gYnVmZmVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7dHlwZTogJ2ZyYWdtZW50JywgY2hpbGRyZW46IFtdfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge05vZGV9IEtpbmRcbiAgICogICBOb2RlIHR5cGUuXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogICBDb250ZXh0LlxuICAgKiBAcGFyYW0ge0tpbmR9IG5vZGVcbiAgICogICBOb2RlIHRvIGVudGVyLlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiAgIENvcnJlc3BvbmRpbmcgdG9rZW4uXG4gICAqIEBwYXJhbSB7T25FbnRlckVycm9yIHwgdW5kZWZpbmVkfSBbZXJyb3JIYW5kbGVyXVxuICAgKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGlzIHRva2VuIGlzIG9wZW4sIGJ1dCBpdCBpcyBjbG9zZWQgYnkgc29tZXRoaW5nIGVsc2UuXG4gICAqIEByZXR1cm5zIHtLaW5kfVxuICAgKiAgIFRoZSBnaXZlbiBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXIobm9kZSwgdG9rZW4sIGVycm9ySGFuZGxlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChwYXJlbnQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gcGFyZW50LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEFzc3VtZSBgTm9kZWAgY2FuIGV4aXN0IGFzIGEgY2hpbGQgb2YgYHBhcmVudGAuXG4gICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSlcbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSlcbiAgICB0aGlzLnRva2VuU3RhY2sucHVzaChbdG9rZW4sIGVycm9ySGFuZGxlcl0pXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGVuZGAgd2lsbCBiZSBwYXRjaGVkIGxhdGVyLlxuICAgIG5vZGUucG9zaXRpb24gPSB7c3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KX1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb3NlciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SGFuZGxlfSBbYW5kXVxuICAgKiAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFsc28gcnVuLlxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKiAgIEhhbmRsZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNsb3NlcihhbmQpIHtcbiAgICByZXR1cm4gY2xvc2VcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb3NlKHRva2VuKSB7XG4gICAgICBpZiAoYW5kKSBhbmQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIGV4aXQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiAgIENvbnRleHQuXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqICAgQ29ycmVzcG9uZGluZyB0b2tlbi5cbiAgICogQHBhcmFtIHtPbkV4aXRFcnJvciB8IHVuZGVmaW5lZH0gW29uRXhpdEVycm9yXVxuICAgKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbm90aGVyIHRva2VuIGlzIG9wZW4uXG4gICAqIEByZXR1cm5zIHtOb2RlfVxuICAgKiAgIFRoZSBjbG9zZWQgbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXQodG9rZW4sIG9uRXhpdEVycm9yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIGBub2RlYCcpXG4gICAgY29uc3Qgb3BlbiA9IHRoaXMudG9rZW5TdGFjay5wb3AoKVxuXG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY2xvc2UgYCcgK1xuICAgICAgICAgIHRva2VuLnR5cGUgK1xuICAgICAgICAgICdgICgnICtcbiAgICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHRva2VuLnN0YXJ0LCBlbmQ6IHRva2VuLmVuZH0pICtcbiAgICAgICAgICAnKTogaXTigJlzIG5vdCBvcGVuJ1xuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3BlblswXS50eXBlICE9PSB0b2tlbi50eXBlKSB7XG4gICAgICBpZiAob25FeGl0RXJyb3IpIHtcbiAgICAgICAgb25FeGl0RXJyb3IuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcGVuWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQobm9kZS50eXBlICE9PSAnZnJhZ21lbnQnLCAndW5leHBlY3RlZCBmcmFnbWVudCBgZXhpdGBlZCcpXG4gICAgYXNzZXJ0KG5vZGUucG9zaXRpb24sICdleHBlY3RlZCBgcG9zaXRpb25gIHRvIGJlIGRlZmluZWQnKVxuICAgIG5vZGUucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzLnN0YWNrLnBvcCgpKVxuICB9XG5cbiAgLy9cbiAgLy8gSGFuZGxlcnMuXG4gIC8vXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0b3JkZXJlZCgpIHtcbiAgICBzZXREYXRhKCdleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0aXRlbXZhbHVlKHRva2VuKSB7XG4gICAgaWYgKGdldERhdGEoJ2V4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZScpKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgICAgYXNzZXJ0KGFuY2VzdG9yLCAnZXhwZWN0ZWQgbm9kZXMgb24gc3RhY2snKVxuICAgICAgYXNzZXJ0KGFuY2VzdG9yLnR5cGUgPT09ICdsaXN0JywgJ2V4cGVjdGVkIGxpc3Qgb24gc3RhY2snKVxuICAgICAgYW5jZXN0b3Iuc3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLFxuICAgICAgICBjb25zdGFudHMubnVtZXJpY0Jhc2VEZWNpbWFsXG4gICAgICApXG4gICAgICBzZXREYXRhKCdleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG4gICAgbm9kZS5sYW5nID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZW1ldGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29kZScsICdleHBlY3RlZCBjb2RlIG9uIHN0YWNrJylcbiAgICBub2RlLm1ldGEgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlKCkge1xuICAgIC8vIEV4aXQgaWYgdGhpcyBpcyB0aGUgY2xvc2luZyBmZW5jZS5cbiAgICBpZiAoZ2V0RGF0YSgnZmxvd0NvZGVJbnNpZGUnKSkgcmV0dXJuXG4gICAgdGhpcy5idWZmZXIoKVxuICAgIHNldERhdGEoJ2Zsb3dDb2RlSW5zaWRlJywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgICBzZXREYXRhKCdmbG93Q29kZUluc2lkZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWluZGVudGVkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC8oXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcodG9rZW4pIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUubGFiZWwgPSBsYWJlbFxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdoZWFkaW5nJywgJ2V4cGVjdGVkIGhlYWRpbmcgb24gc3RhY2snKVxuXG4gICAgaWYgKCFub2RlLmRlcHRoKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLmxlbmd0aFxuXG4gICAgICBhc3NlcnQoXG4gICAgICAgIGRlcHRoID09PSAxIHx8XG4gICAgICAgICAgZGVwdGggPT09IDIgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gMyB8fFxuICAgICAgICAgIGRlcHRoID09PSA0IHx8XG4gICAgICAgICAgZGVwdGggPT09IDUgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gNixcbiAgICAgICAgJ2V4cGVjdGVkIGBkZXB0aGAgYmV0d2VlbiBgMWAgYW5kIGA2YCdcbiAgICAgIClcblxuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0KCkge1xuICAgIHNldERhdGEoJ3NldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaGVhZGluZycsICdleHBlY3RlZCBoZWFkaW5nIG9uIHN0YWNrJylcblxuICAgIG5vZGUuZGVwdGggPVxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikuY2hhckNvZGVBdCgwKSA9PT0gY29kZXMuZXF1YWxzVG8gPyAxIDogMlxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmcoKSB7XG4gICAgc2V0RGF0YSgnc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZycpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmVudGVyZGF0YSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIG5vZGUsICdleHBlY3RlZCBwYXJlbnQgb24gc3RhY2snKVxuXG4gICAgbGV0IHRhaWwgPSBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblxuICAgIGlmICghdGFpbCB8fCB0YWlsLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgLy8gQWRkIGEgbmV3IHRleHQgbm9kZS5cbiAgICAgIHRhaWwgPSB0ZXh0KClcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdl4oCZbGwgYWRkIGBlbmRgIGxhdGVyLlxuICAgICAgdGFpbC5wb3NpdGlvbiA9IHtzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpfVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogQXNzdW1lIGBwYXJlbnRgIGFjY2VwdHMgYHRleHRgLlxuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRhaWwpXG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKHRhaWwpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkYXRhKHRva2VuKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQodGFpbCwgJ2V4cGVjdGVkIGEgYG5vZGVgIHRvIGJlIG9uIHRoZSBzdGFjaycpXG4gICAgYXNzZXJ0KCd2YWx1ZScgaW4gdGFpbCwgJ2V4cGVjdGVkIGEgYGxpdGVyYWxgIHRvIGJlIG9uIHRoZSBzdGFjaycpXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24sICdleHBlY3RlZCBgbm9kZWAgdG8gaGF2ZSBhbiBvcGVuIHBvc2l0aW9uJylcbiAgICB0YWlsLnZhbHVlICs9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsaW5lZW5kaW5nKHRva2VuKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChjb250ZXh0LCAnZXhwZWN0ZWQgYG5vZGVgJylcblxuICAgIC8vIElmIHdl4oCZcmUgYXQgYSBoYXJkIGJyZWFrLCBpbmNsdWRlIHRoZSBsaW5lIGVuZGluZyBpbiB0aGVyZS5cbiAgICBpZiAoZ2V0RGF0YSgnYXRIYXJkQnJlYWsnKSkge1xuICAgICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gY29udGV4dCwgJ2V4cGVjdGVkIGBwYXJlbnRgJylcbiAgICAgIGNvbnN0IHRhaWwgPSBjb250ZXh0LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uLCAnZXhwZWN0ZWQgdGFpbCB0byBoYXZlIGEgc3RhcnRpbmcgcG9zaXRpb24nKVxuICAgICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gICAgICBzZXREYXRhKCdhdEhhcmRCcmVhaycpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhZ2V0RGF0YSgnc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZycpICYmXG4gICAgICBjb25maWcuY2FuQ29udGFpbkVvbHMuaW5jbHVkZXMoY29udGV4dC50eXBlKVxuICAgICkge1xuICAgICAgb25lbnRlcmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRoYXJkYnJlYWsoKSB7XG4gICAgc2V0RGF0YSgnYXRIYXJkQnJlYWsnLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0aHRtbGZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaHRtbCcsICdleHBlY3RlZCBodG1sIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sdGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdodG1sJywgJ2V4cGVjdGVkIGh0bWwgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGV0ZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2lubGluZUNvZGUnLCAnZXhwZWN0ZWQgaW5saW5lIGNvZGUgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxpbmsoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpbmsnLCAnZXhwZWN0ZWQgbGluayBvbiBzdGFjaycpXG5cbiAgICAvLyBOb3RlOiB0aGVyZSBhcmUgYWxzbyBgaWRlbnRpZmllcmAgYW5kIGBsYWJlbGAgZmllbGRzIG9uIHRoaXMgbGluayBub2RlIVxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIC8gY2xlYW5lZCBoZXJlLlxuXG4gICAgLy8gVG8gZG86IGNsZWFuLlxuICAgIGlmIChnZXREYXRhKCdpblJlZmVyZW5jZScpKSB7XG4gICAgICAvKiogQHR5cGUge1JlZmVyZW5jZVR5cGV9ICovXG4gICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gZ2V0RGF0YSgncmVmZXJlbmNlVHlwZScpIHx8ICdzaG9ydGN1dCdcblxuICAgICAgbm9kZS50eXBlICs9ICdSZWZlcmVuY2UnXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBub2RlLnJlZmVyZW5jZVR5cGUgPSByZWZlcmVuY2VUeXBlXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS51cmxcbiAgICAgIGRlbGV0ZSBub2RlLnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmlkZW50aWZpZXJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmxhYmVsXG4gICAgfVxuXG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRpbWFnZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaW1hZ2UnLCAnZXhwZWN0ZWQgaW1hZ2Ugb24gc3RhY2snKVxuXG4gICAgLy8gTm90ZTogdGhlcmUgYXJlIGFsc28gYGlkZW50aWZpZXJgIGFuZCBgbGFiZWxgIGZpZWxkcyBvbiB0aGlzIGxpbmsgbm9kZSFcbiAgICAvLyBUaGVzZSBhcmUgdXNlZCAvIGNsZWFuZWQgaGVyZS5cblxuICAgIC8vIFRvIGRvOiBjbGVhbi5cbiAgICBpZiAoZ2V0RGF0YSgnaW5SZWZlcmVuY2UnKSkge1xuICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2VUeXBlfSAqL1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IGdldERhdGEoJ3JlZmVyZW5jZVR5cGUnKSB8fCAnc2hvcnRjdXQnXG5cbiAgICAgIG5vZGUudHlwZSArPSAnUmVmZXJlbmNlJ1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUudXJsXG4gICAgICBkZWxldGUgbm9kZS50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5pZGVudGlmaWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5sYWJlbFxuICAgIH1cblxuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWx0ZXh0KHRva2VuKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgIGFzc2VydChhbmNlc3RvciwgJ2V4cGVjdGVkIGFuY2VzdG9yIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBhbmNlc3Rvci50eXBlID09PSAnaW1hZ2UnIHx8IGFuY2VzdG9yLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHN0YXNoIHRoaXMgb24gdGhlIG5vZGUsIGFzIGl0IG1pZ2h0IGJlY29tZSBhIHJlZmVyZW5jZVxuICAgIC8vIGxhdGVyLlxuICAgIGFuY2VzdG9yLmxhYmVsID0gZGVjb2RlU3RyaW5nKHN0cmluZylcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzYW1lIGFzIGFib3ZlLlxuICAgIGFuY2VzdG9yLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKHN0cmluZykudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWwoKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQoZnJhZ21lbnQsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoZnJhZ21lbnQudHlwZSA9PT0gJ2ZyYWdtZW50JywgJ2V4cGVjdGVkIGZyYWdtZW50IG9uIHN0YWNrJylcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG5cbiAgICAvLyBBc3N1bWUgYSByZWZlcmVuY2UuXG4gICAgc2V0RGF0YSgnaW5SZWZlcmVuY2UnLCB0cnVlKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PFN0YXRpY1BocmFzaW5nQ29udGVudD59ICovXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBBc3N1bWUgc3RhdGljIHBocmFzaW5nIGNvbnRlbnQuXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGZyYWdtZW50LmNoaWxkcmVuXG5cbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFsdCA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcbiAgICBub2RlLnVybCA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNlKCkge1xuICAgIHNldERhdGEoJ2luUmVmZXJlbmNlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZW50ZXJyZWZlcmVuY2UoKSB7XG4gICAgc2V0RGF0YSgncmVmZXJlbmNlVHlwZScsICdjb2xsYXBzZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVmZXJlbmNlc3RyaW5nKHRva2VuKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZS50eXBlID09PSAnaW1hZ2UnIHx8IG5vZGUudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIHJlZmVyZW5jZSBvciBsaW5rIHJlZmVyZW5jZSBvbiBzdGFjaydcbiAgICApXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzdGFzaCB0aGlzIG9uIHRoZSBub2RlLCBhcyBpdCBtaWdodCBiZWNvbWUgYSByZWZlcmVuY2VcbiAgICAvLyBsYXRlci5cbiAgICBub2RlLmxhYmVsID0gbGFiZWxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzYW1lIGFzIGFib3ZlLlxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICAgIHNldERhdGEoJ3JlZmVyZW5jZVR5cGUnLCAnZnVsbCcpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIodG9rZW4pIHtcbiAgICBhc3NlcnQoXG4gICAgICB0b2tlbi50eXBlID09PSAnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYycgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsJ1xuICAgIClcbiAgICBzZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJywgdG9rZW4udHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSh0b2tlbikge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGNvbnN0IHR5cGUgPSBnZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJylcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgdmFsdWVcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICB2YWx1ZSA9IGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWNcbiAgICAgICAgICA/IGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWxcbiAgICAgICAgICA6IGNvbnN0YW50cy5udW1lcmljQmFzZUhleGFkZWNpbWFsXG4gICAgICApXG4gICAgICBzZXREYXRhKCdjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoZGF0YSlcbiAgICAgIGFzc2VydChyZXN1bHQgIT09IGZhbHNlLCAnZXhwZWN0ZWQgcmVmZXJlbmNlIHRvIGRlY29kZScpXG4gICAgICB2YWx1ZSA9IHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgYXNzZXJ0KHRhaWwsICdleHBlY3RlZCBgbm9kZWAnKVxuICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uLCAnZXhwZWN0ZWQgYG5vZGUucG9zaXRpb25gJylcbiAgICBhc3NlcnQoJ3ZhbHVlJyBpbiB0YWlsLCAnZXhwZWN0ZWQgYG5vZGUudmFsdWVgJylcbiAgICB0YWlsLnZhbHVlICs9IHZhbHVlXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtwcm90b2NvbCh0b2tlbikge1xuICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycsICdleHBlY3RlZCBsaW5rIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua2VtYWlsKHRva2VuKSB7XG4gICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdsaW5rJywgJ2V4cGVjdGVkIGxpbmsgb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSAnbWFpbHRvOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLy9cbiAgLy8gQ3JlYXRlcnMuXG4gIC8vXG5cbiAgLyoqIEByZXR1cm5zIHtCbG9ja3F1b3RlfSAqL1xuICBmdW5jdGlvbiBibG9ja1F1b3RlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2Jsb2NrcXVvdGUnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge0NvZGV9ICovXG4gIGZ1bmN0aW9uIGNvZGVGbG93KCkge1xuICAgIHJldHVybiB7dHlwZTogJ2NvZGUnLCBsYW5nOiBudWxsLCBtZXRhOiBudWxsLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0lubGluZUNvZGV9ICovXG4gIGZ1bmN0aW9uIGNvZGVUZXh0KCkge1xuICAgIHJldHVybiB7dHlwZTogJ2lubGluZUNvZGUnLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0RlZmluaXRpb259ICovXG4gIGZ1bmN0aW9uIGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkZWZpbml0aW9uJyxcbiAgICAgIGlkZW50aWZpZXI6ICcnLFxuICAgICAgbGFiZWw6IG51bGwsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogJydcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybnMge0VtcGhhc2lzfSAqL1xuICBmdW5jdGlvbiBlbXBoYXNpcygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlbXBoYXNpcycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SGVhZGluZ30gKi9cbiAgZnVuY3Rpb24gaGVhZGluZygpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZXB0aGAgd2lsbCBiZSBzZXQgbGF0ZXIuXG4gICAgcmV0dXJuIHt0eXBlOiAnaGVhZGluZycsIGRlcHRoOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7QnJlYWt9ICovXG4gIGZ1bmN0aW9uIGhhcmRCcmVhaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdicmVhayd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0hUTUx9ICovXG4gIGZ1bmN0aW9uIGh0bWwoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnaHRtbCcsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SW1hZ2V9ICovXG4gIGZ1bmN0aW9uIGltYWdlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2ltYWdlJywgdGl0bGU6IG51bGwsIHVybDogJycsIGFsdDogbnVsbH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7TGlua30gKi9cbiAgZnVuY3Rpb24gbGluaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdsaW5rJywgdGl0bGU6IG51bGwsIHVybDogJycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdH1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3QodG9rZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgb3JkZXJlZDogdG9rZW4udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtMaXN0SXRlbX1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RJdGVtKHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoZWQuXG4gICAgICBzcHJlYWQ6IHRva2VuLl9zcHJlYWQsXG4gICAgICBjaGVja2VkOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtQYXJhZ3JhcGh9ICovXG4gIGZ1bmN0aW9uIHBhcmFncmFwaCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdwYXJhZ3JhcGgnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge1N0cm9uZ30gKi9cbiAgZnVuY3Rpb24gc3Ryb25nKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3N0cm9uZycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7VGV4dH0gKi9cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtUaGVtYXRpY0JyZWFrfSAqL1xuICBmdW5jdGlvbiB0aGVtYXRpY0JyZWFrKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3RoZW1hdGljQnJlYWsnfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhIHBvaW50LWxpa2UgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gZFxuICogICBQb2ludC1saWtlIHZhbHVlLlxuICogQHJldHVybnMge1BvaW50fVxuICogICB1bmlzdCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcG9pbnQoZCkge1xuICByZXR1cm4ge2xpbmU6IGQubGluZSwgY29sdW1uOiBkLmNvbHVtbiwgb2Zmc2V0OiBkLm9mZnNldH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29tYmluZWRcbiAqIEBwYXJhbSB7QXJyYXk8RXh0ZW5zaW9uIHwgQXJyYXk8RXh0ZW5zaW9uPj59IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoY29tYmluZWQsIGV4dGVuc2lvbnMpIHtcbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb25zW2luZGV4XVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb25maWd1cmUoY29tYmluZWQsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbnNpb24oY29tYmluZWQsIHZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29uZmlnfSBjb21iaW5lZFxuICogQHBhcmFtIHtFeHRlbnNpb259IGV4dGVuc2lvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGV4dGVuc2lvbihjb21iaW5lZCwgZXh0ZW5zaW9uKSB7XG4gIC8qKiBAdHlwZSB7a2V5b2YgRXh0ZW5zaW9ufSAqL1xuICBsZXQga2V5XG5cbiAgZm9yIChrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgaWYgKG93bi5jYWxsKGV4dGVuc2lvbiwga2V5KSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NhbkNvbnRhaW5Fb2xzJykge1xuICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgIGNvbWJpbmVkW2tleV0ucHVzaCguLi5yaWdodClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICd0cmFuc2Zvcm1zJykge1xuICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgIGNvbWJpbmVkW2tleV0ucHVzaCguLi5yaWdodClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdlbnRlcicgfHwga2V5ID09PSAnZXhpdCcpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbWJpbmVkW2tleV0sIHJpZ2h0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBAdHlwZSB7T25FbnRlckVycm9yfSAqL1xuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGNsb3NlIGAnICtcbiAgICAgICAgbGVmdC50eXBlICtcbiAgICAgICAgJ2AgKCcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IGxlZnQuc3RhcnQsIGVuZDogbGVmdC5lbmR9KSArXG4gICAgICAgICcpOiBhIGRpZmZlcmVudCB0b2tlbiAoYCcgK1xuICAgICAgICByaWdodC50eXBlICtcbiAgICAgICAgJ2AsICcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHJpZ2h0LnN0YXJ0LCBlbmQ6IHJpZ2h0LmVuZH0pICtcbiAgICAgICAgJykgaXMgb3BlbidcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBkb2N1bWVudCwgYSB0b2tlbiAoYCcgK1xuICAgICAgICByaWdodC50eXBlICtcbiAgICAgICAgJ2AsICcgK1xuICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHJpZ2h0LnN0YXJ0LCBlbmQ6IHJpZ2h0LmVuZH0pICtcbiAgICAgICAgJykgaXMgc3RpbGwgb3BlbidcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsInRvU3RyaW5nIiwicGFyc2UiLCJwcmVwcm9jZXNzIiwicG9zdHByb2Nlc3MiLCJkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlIiwiZGVjb2RlU3RyaW5nIiwibm9ybWFsaXplSWRlbnRpZmllciIsImNvZGVzIiwiY29uc3RhbnRzIiwidHlwZXMiLCJkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZSIsInN0cmluZ2lmeVBvc2l0aW9uIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJmcm9tTWFya2Rvd24iLCJ2YWx1ZSIsImVuY29kaW5nIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsImNvbXBpbGVyIiwiZG9jdW1lbnQiLCJ3cml0ZSIsImNvbmZpZyIsInRyYW5zZm9ybXMiLCJjYW5Db250YWluRW9scyIsImVudGVyIiwiYXV0b2xpbmsiLCJvcGVuZXIiLCJsaW5rIiwiYXV0b2xpbmtQcm90b2NvbCIsIm9uZW50ZXJkYXRhIiwiYXV0b2xpbmtFbWFpbCIsImF0eEhlYWRpbmciLCJoZWFkaW5nIiwiYmxvY2tRdW90ZSIsImNoYXJhY3RlckVzY2FwZSIsImNoYXJhY3RlclJlZmVyZW5jZSIsImNvZGVGZW5jZWQiLCJjb2RlRmxvdyIsImNvZGVGZW5jZWRGZW5jZUluZm8iLCJidWZmZXIiLCJjb2RlRmVuY2VkRmVuY2VNZXRhIiwiY29kZUluZGVudGVkIiwiY29kZVRleHQiLCJjb2RlVGV4dERhdGEiLCJkYXRhIiwiY29kZUZsb3dWYWx1ZSIsImRlZmluaXRpb24iLCJkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmciLCJkZWZpbml0aW9uTGFiZWxTdHJpbmciLCJkZWZpbml0aW9uVGl0bGVTdHJpbmciLCJlbXBoYXNpcyIsImhhcmRCcmVha0VzY2FwZSIsImhhcmRCcmVhayIsImhhcmRCcmVha1RyYWlsaW5nIiwiaHRtbEZsb3ciLCJodG1sIiwiaHRtbEZsb3dEYXRhIiwiaHRtbFRleHQiLCJodG1sVGV4dERhdGEiLCJpbWFnZSIsImxhYmVsIiwibGlzdEl0ZW0iLCJsaXN0SXRlbVZhbHVlIiwib25lbnRlcmxpc3RpdGVtdmFsdWUiLCJsaXN0T3JkZXJlZCIsImxpc3QiLCJvbmVudGVybGlzdG9yZGVyZWQiLCJsaXN0VW5vcmRlcmVkIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwib25lbnRlcnJlZmVyZW5jZSIsInJlZmVyZW5jZVN0cmluZyIsInJlc291cmNlRGVzdGluYXRpb25TdHJpbmciLCJyZXNvdXJjZVRpdGxlU3RyaW5nIiwic2V0ZXh0SGVhZGluZyIsInN0cm9uZyIsInRoZW1hdGljQnJlYWsiLCJleGl0IiwiY2xvc2VyIiwiYXR4SGVhZGluZ1NlcXVlbmNlIiwib25leGl0YXR4aGVhZGluZ3NlcXVlbmNlIiwib25leGl0YXV0b2xpbmtlbWFpbCIsIm9uZXhpdGF1dG9saW5rcHJvdG9jb2wiLCJjaGFyYWN0ZXJFc2NhcGVWYWx1ZSIsIm9uZXhpdGRhdGEiLCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCIsIm9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlciIsImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMiLCJjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZSIsIm9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlIiwib25leGl0Y29kZWZlbmNlZCIsImNvZGVGZW5jZWRGZW5jZSIsIm9uZXhpdGNvZGVmZW5jZWRmZW5jZSIsIm9uZXhpdGNvZGVmZW5jZWRmZW5jZWluZm8iLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhIiwib25leGl0Y29kZWluZGVudGVkIiwib25leGl0Y29kZXRleHQiLCJvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmciLCJvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmciLCJvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmciLCJvbmV4aXRoYXJkYnJlYWsiLCJvbmV4aXRodG1sZmxvdyIsIm9uZXhpdGh0bWx0ZXh0Iiwib25leGl0aW1hZ2UiLCJvbmV4aXRsYWJlbCIsImxhYmVsVGV4dCIsIm9uZXhpdGxhYmVsdGV4dCIsImxpbmVFbmRpbmciLCJvbmV4aXRsaW5lZW5kaW5nIiwib25leGl0bGluayIsIm9uZXhpdHJlZmVyZW5jZXN0cmluZyIsIm9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmciLCJvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nIiwicmVzb3VyY2UiLCJvbmV4aXRyZXNvdXJjZSIsIm9uZXhpdHNldGV4dGhlYWRpbmciLCJzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlIiwib25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSIsInNldGV4dEhlYWRpbmdUZXh0Iiwib25leGl0c2V0ZXh0aGVhZGluZ3RleHQiLCJjb25maWd1cmUiLCJtZGFzdEV4dGVuc2lvbnMiLCJjb21waWxlIiwiZXZlbnRzIiwidHJlZSIsInR5cGUiLCJjaGlsZHJlbiIsImNvbnRleHQiLCJzdGFjayIsInRva2VuU3RhY2siLCJyZXN1bWUiLCJzZXREYXRhIiwiZ2V0RGF0YSIsImxpc3RTdGFjayIsImluZGV4IiwibGVuZ3RoIiwicHVzaCIsInRhaWwiLCJwb3AiLCJwcmVwYXJlTGlzdCIsImhhbmRsZXIiLCJjYWxsIiwiT2JqZWN0IiwiYXNzaWduIiwic2xpY2VTZXJpYWxpemUiLCJkZWZhdWx0T25FcnJvciIsInBvc2l0aW9uIiwic3RhcnQiLCJwb2ludCIsImxpbmUiLCJjb2x1bW4iLCJvZmZzZXQiLCJlbmQiLCJjb250YWluZXJCYWxhbmNlIiwibGlzdFNwcmVhZCIsImxpbmVJbmRleCIsImZpcnN0QmxhbmtMaW5lSW5kZXgiLCJhdE1hcmtlciIsImV2ZW50IiwibGluZUVuZGluZ0JsYW5rIiwibGluZVByZWZpeCIsImxpc3RJdGVtTWFya2VyIiwibGlzdEl0ZW1QcmVmaXgiLCJsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UiLCJ0YWlsSW5kZXgiLCJ0YWlsRXZlbnQiLCJibG9ja1F1b3RlUHJlZml4IiwiYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UiLCJibG9ja1F1b3RlTWFya2VyIiwibGlzdEl0ZW1JbmRlbnQiLCJfc3ByZWFkIiwic3BsaWNlIiwia2V5IiwiY3JlYXRlIiwiYW5kIiwib3BlbiIsInRva2VuIiwibm9kZSIsImVycm9ySGFuZGxlciIsInBhcmVudCIsImNsb3NlIiwib25FeGl0RXJyb3IiLCJFcnJvciIsImFuY2VzdG9yIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJudW1lcmljQmFzZURlY2ltYWwiLCJsYW5nIiwibWV0YSIsInJlcGxhY2UiLCJpZGVudGlmaWVyIiwidG9Mb3dlckNhc2UiLCJ0aXRsZSIsInVybCIsImRlcHRoIiwiY2hhckNvZGVBdCIsImVxdWFsc1RvIiwidGV4dCIsImluY2x1ZGVzIiwicmVmZXJlbmNlVHlwZSIsInN0cmluZyIsImZyYWdtZW50IiwiYWx0IiwibnVtZXJpY0Jhc2VIZXhhZGVjaW1hbCIsInJlc3VsdCIsIm9yZGVyZWQiLCJzcHJlYWQiLCJjaGVja2VkIiwiZCIsImNvbWJpbmVkIiwiZXh0ZW5zaW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImV4dGVuc2lvbiIsInJpZ2h0IiwibGVmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/mdast-util-from-markdown@1.3.0/node_modules/mdast-util-from-markdown/dev/lib/index.js\n");

/***/ })

};
;